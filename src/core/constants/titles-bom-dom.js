import tableImg from '../../assets/images/table-example.png';
import indexedDB from '../../assets/images/indexedDb.png';
import nodeInsertLikeText from '../../assets/images/node-insert-like-text.png';
import nodeInsertLikeHTML from '../../assets/images/node-insert-like-html.png';
import elementsSizing from '../../assets/images/elements-sizing.png';
import mouseEvents from '../../assets/images/mouse-events.png';
import slotExample from '../../assets/images/slot-example.png';

export const titlesBomDomWithDescription = [
    {
        title: "Window/Dom/Bom",
        shortDesc: "<strong>Window</strong> - это контекст выполнения и глобальный объект для этого контекста. JavaScript <strong>document</strong> содержит DOM, инициализированный при разборе. HTMLscreen описывает физическое отображение на весь экран. <br><br> <strong>DOM</strong> (document object model) - (страница в виде объекта с точкой входа document) <br><br> <strong>BOM</strong> (browser object model) - (браузер в виде объекта navigator, location, setTimeout, alert, prompt, confirm)",
        description: ""
    },
    {
        title: "Селекторы узлов DOM",
        shortDesc: `Все узлы делятся на тесктовые узлы и элементы. В основном взаимодейтсвие идет с элементами поэтому мы используем методы для элементов, а не для всех узлов.<br> Выбрав элемент в меню разработчика можно нажать esc и  в консоли обращаться к выбранному элементу через $0 <br><code><ul><li style="padding:0; margin: 0;">document.body.<strong>childNodes</strong>                          псевдомассив всех детей элемента первого уровня вложенности, for_of  в нем работает</li><li><strong>.children</strong>           тоже самое только возвращает именно элементы, без текстовых узлов и т.д. </li><li>elem.<strong>firstChild</strong>           первый ребенок элемента. (=== elem.childNodes[0] )</li><li><strong>.firstElementChild</strong>       первый ребенок элемента (только элемент)</li><li>elem.<strong>lastChild</strong>         последний ребенок элемента ( === elem.childNodes[elem.childNodes.length - 1] )</li><li><strong>.lastElementChild</strong>        последний ребенок элемента (только элемент)</li><li>elem.<strong>hasChildNodes()</strong>         проверяет есть ли дети у элемента </li><li>document.body.<strong>parentNode</strong>         возвращает родителя (любого) </li>
        <li><strong>.parentElement</strong>         возвращает родительский элемент </li><li>document.head.<strong>nextSibling </strong>            следующий или правый сосед</li><li><strong>.nextElementSibling </strong>     тоже самое только элемент </li><li>document.body.<strong>previousSibling</strong>        предыдущий или левый сосед </li><li><strong>.previousElementSibling </strong>      тоже самое только элемент </li>    <hr><li>document.<strong>getElementById</strong>('elem');  вовращает элемент по id</li><li>document.<strong>querySelectorAll</strong>('ul > li:last-child');  возвращает массив элементов </li><li>elem.<strong>querySelector</strong>(css)              возвращает первый элемент удовлетворяющий запрос </li><li>elem.<strong>matches</strong>(css)       вовзвращает true or false если элемент удовлетворяет css селектор</li><li>elem.<strong>closest</strong>(css)          возвращает ближайшего предка (вверх), который удовлетворяет сss селектору</li><li>elem.<strong>getElementsByTagName</strong>(tag)  возвращает коллекцию элементов по тегу.</li><li>elem.<strong>getElementsByClassName</strong>(className)      возвращает коллекцию элементов по классу </li> <li>document.<strong>getElementsByName</strong>(name)  возвращает коллекцию элементов с атрибутом name </li><li>elemA.<strong>contains</strong>(elemB)      возвращает true, если А содержит внутри себя В</li></ul>`,
        description:""
    },
    {
        title: "Table",
        shortDesc: `<ul><li>table.<strong>rows</strong>            коллекция строк &lt;tr> таблицы.</li><li>table.<strong>caption/tHead/tFoot</strong>  ссылки на &lt;caption>, &lt;thead>, &lt;tfoot></li><li>table.<strong>tBodies</strong>         коллекция элементов таблицы &lt;tbody></li><li>tbody.<strong>rows, thead.rows, tfoot.rows </strong>         коллекция строк &lt;tr> секции</li><li>tr.<strong>cells</strong>              коллекция &lt;td> и &lt;th> ячеек, внутри строки &lt;tr>.</li><li>tr.<strong>sectionRowIndex</strong>       номер строки &lt;tr> в текущей секции &lt;thead>/&lt;tbody>/&lt;tfoot>.</li><li>tr.<strong>rowIndex</strong>          номер строки &lt;tr> в таблице (включая все строки таблицы).</li><li>td.<strong>cellIndex</strong>             номер ячейки в строке &lt;tr>.</li></ul><br><img alt='table-example' style="width: 15rem;" src='${tableImg}'/>`,
        description: ""
    },
    {
        title: "Содержимое узлов",
        shortDesc: `<ul><li>alert(elem.<strong>nodeType</strong>)         возвращает число (1 - если узел-элемент, 3- если текстовый узел, 9 -объект документа и.т.д.)</li><li>alert(document.body.<strong>nodeName</strong> );      // BODY  выводит название тега в верхнем регистре если не xhtml</li><li>alert( document.body.<strong>tagName</strong> );       // BODY для узлов не элементов описывает что это за узел</li><li>document.body.<strong>innerHTML</strong>        возвращает содержимое элемента в виде строки. Через = записывает новое содержимое</li><li>alert(elem.<strong>outerHTML</strong>)        возвращает содержимое элемента + сам элемент в виде строки. Через = вставляет на его место новый элемент </li><li>div.firstChild.<strong>data / nodeValue</strong>      возвращает содержимое текстового элемента</li><li>news.<strong>textContent</strong>        возвращает только текст, вычитая все вложенные тэги внутри элемента</li><li>elem.<strong>hidden</strong> = true;        скрывает элемент (как display:none)</li></ul> <hr> 
        Когда движок парсит html, он создает для каждого элемента объект, где свойства этого объекта все стандартные атрибуты элемента. У каждого элемента могут быть записаны нестандартные атрибуты, но они не записываются в свойства объекта при парсинге. Для этого есть такие методы в js <code><span class='code-example'><body id="test" something="non-standard"></span></code>. <ul><li>elem.<strong>hasAttribute</strong>(name)      проверяет наличие атрибута.</li><li>elem.<strong>getAttribute</strong>(name)         получает значение атрибута.</li> elem.<strong>setAttribute</strong>(name, value)    устанавливает значение атрибута.</li><li>elem.<strong>removeAttribute</strong>(name)    удаляет атрибут.</li><li>elem.<strong>attributes</strong>                           возвращает коллекцию атрибутов name:value </li><li><code><span class='code-example'><body <strong>data-about</strong>="Elephants"><br>&lt;script><br>alert(document.body.<strong>dataset.about</strong>);   // Elephants  // Доступ к атрибуту тега, который записан через data-...<br>&lt;/script>`
    },
    {
        title: "Изменение документа",
        shortDesc: `<div style="float:left"><code><span class='code-example'>&lt;script><br>let div = document.<b>createElement</b>('div'); <br> div.<b>className</b> = "alert";<br>div.<b>innerHTML</b> = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";<br>document.body.<b>append</b>(div);           добавляет узлы или строки в конец node <br> &lt;/script> <br><br> node.<b>prepend</b>(...nodes or strings)          вставляет узлы или строки в начало node, <br>node.<b>before</b>(...nodes or strings)           вставляет узлы или строки до node, <br> node.<b>after</b>(...nodes or strings)                    вставляет узлы или строки после node, <br>node.<b>replaceWith</b>(...nodes or strings)         заменяет node заданными узлами или строками. </span></code></div><div style="float:right;"><img style="width: 15rem;" src=${nodeInsertLikeText} /></div><hr style="clear:both"> <code><span class='code-example'>node.<b>remove</b>()               удаляет node <br>let div2 = div.<b>cloneNode</b>(true)        клонирует элемент (true - глубоко, false - без дочерних) <br>let fragment = <b>new DocumentFragment</b>();     создает узел обертку, которая исчезает при вставке, например для вставки многих &lt;li /> (исп редко) <br> document.<b>write</b>('&lt;b>Вставить что-то&lt;/b>')  добавляет содержимое на веб страницу( старый метод)</span></code> <hr> <div style="float: left"><code><span class='code-example'>&lt;div id="div">&lt;/div><br>&lt;script><br> div.<b>insertAdjacentHTML</b>('beforebegin', '&lt;p>Привет&lt;/p>'); <br> div.<b>insertAdjacentHTML</b>('afterend', '&lt;p>Пока&lt;/p>'); <br>&lt;/script> <br><br>"<b>beforebegin</b>" – вставить html непосредственно перед elem, <br>"<b>afterbegin</b>" – вставить html в начало elem, <br>"<b>beforeend</b>" – вставить html в конец elem, <br> "<b>afterend</b>" – вставить html непосредственно после elem.</div> <div style="float: right"><img style="width: 15rem" src=${nodeInsertLikeHTML} /></div>`,
        description : ""
    },
    {
        title: "js/css класы, стили",
        shortDesc: "document.body.<b>className </b>            возвращает класс <br> document.body.<b>className =</b> 'red'             заменяет класс <br> document.body.<b>classList</b>               перебираемая коллекция классов<br> document.body.<b>classList.add</b>('article');        добавляет класс <br> document.body.<b>classList.remove</b>('article');      удаляет класс <br> elem.<b>classList.toggle</b>('class')        добавить класс, если его нет, иначе удалить <br> elem.<b>classList.contains</b>('class')        проверка наличия класса (true, false) <br> document.body.<b>style</b>.backgroundColor                объект стилей элемента <br> div.style.<b>cssText</b>=`                  устанавливает новый css (если нужно сразу много свойств)<br> color: red !important; <br>width: 100px;<br>`;<br> let <b>cSt</b> = <b>getComputedStyle</b>(document.body);<br> <b>cSt</b>.marginTop                          получаем марджин",
        description: ""
    },
    {
        title: "Получение размеров элемента",
        shortDesc: `<div style='float:left'>alert(example.<b>offsetParent</b>.id);        находится предок элемента, для вычисления координат при рендере<br> alert(example.<b>offsetLeft</b>);            содержат координаты x/y относительно верхнего <br> alert(example.<b>offsetTop</b>)                          левого угла offsetParent. <br><br>function <b>isHidden</b>(elem) {                   проверка видим ли элемент <br> return <b>!elem.offsetWidth && !elem.offsetHeight</b>;     полная внешняя ширина и высота элемента <br> } <br> <ul><li><b>clientLeft</b>                 ширина отступа внутренней левой части элемента от внешней </li><li><b>clientTop</b>                 ширина отступа внутренней левой части элемента от внешней</li><li><b>clientHeight</b>               высота внутренней части элемента без паддингов и скроллбара</li><li><b>clientWidth</b>                ширина внутренней части элемента без паддингов и скроллбара</li><li><b>scrollHeight</b>                тоже самое только со скрытой (прокурученной) областью</li><li><b>scrollWidth</b>                 element.style.height <b>=</b> '$&#123;element.scrollHeight}px'; распахиваем элемент</li><li><b>scrollLeft</b>                ширина невидимой прокрученной области слева</li><li><b>scrollTop</b>                  высота невидимой прокрученной области сверху<br> (насколько прокручено, можно установить принудительно)</li></ul></div><div style='float: right;'><img style="width: 15rem" src=${elementsSizing}/></div> <hr style="clear:both">
        Для получения этих же данных об <b><u>окне браузера</u></b> нам стоит обращаться к <b>document.documentElement</b>.clientWidth (document.documentElement, соответствует тегу &lt;html>) <br>Для получения полной высоты окна изза ошибок разных браузеров стоит это делать так: <br><code><span class='code-example'> let scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight,   document.body.offsetHeight, document.documentElement.offsetHeight,   document.body.clientHeight, document.documentElement.clientHeight ); </span></code><br><br> window.<b>pageYOffset</b>           текущая прокурутка окна сверху для старых Safari (document.body.scrollTop/Left) <br>window.<b>pageXOffset</b>            текущая прокурутка окна слев <br>window.<b>scrollBy</b>(x,y)             прокручивает страницу относительно текущих координат на (влево, вниз) <br><b>scrollTo</b>(pageX,pageY)             прокручивает страницу на абсолютные координаты (влево, вниз) <br> elem.<b>scrollIntoView</b>(top)          прокрутить совместив верх элемента с верхом окна (если top=false то с низом окна) <br> document.body.style.<b>overflow = 'hidden'</b>          запретить прокрутку окна <br> document.body.style.<b>overflow = ''</b>   разрешить прокрутку окна <br>elem.<b>getBoundingClientRect()</b>       возвращает объект в котором  (x,y,width,height,top,bottom,left,right)  элемента относительно окна <br> document.<b>elementFromPoint</b>(X,Y);     возвращает самый глубоко вложенный элемент по заданным координатам находящийся в окне (не в окне - null)`,
        description: ""
    },
    {
        title: "Браузерные события",
        shortDesc: `<b>Браузерные события</b>    (1 стадия - погружение, 2 стадия достижения цели, 3- всплытие ) <code><span class='code-example'><ul><li>&lt;input value='жми' <b>onclick='alert(this.innerHTML)'</b> type='button' id='elem'>       ||     <b>onclick='sayThanks()'</b> </li><li> <b>elem.onclick</b> = function() { alert('Спасибо');};       ||     <b>button.onclick</b> = sayThanks </li><li> <b>elem.addEventListener</b>( 'click' , () => alert('Спасибо!')); <br>elem.<b>removeEventListener</b>( 'click', () => alert('Спасибо!')); </li></ul> </span></code><hr><div style='float: left'><ul><li><b>click / dblclick</b> - клик левой кнопкой мыши (тап на сенсоре) // двойной клик </li><li><b>contextmenu</b> - клик правой кнопкой мыши </li><li><b>mouseover/mouseout</b> - мышь наводится / покидает элемент (Переходы внутри элемента, на его потомки и с них, считаются. Всплывает)</li><li><b>mouseenter, mouseleave</b> - мышь наводится / покидает элемент (переходы на потомков внутри элемента не учитываются. Не всплывает)</li><li><b>mousedown</b> - мышь нажали</li><li><b>mouseup</b> - мышь отжали</li><li><b>mousemove</b> - движение мыши</li><li><b>touchstart, touchend, touchmove</b> - устаревшие события тача (аналогично мыши) </li><li><b>scroll</b> - прокрутка экрана</li></ul><br>Для правильной работы сенсорных экранов, пера, и т.д. был разработан стандарт 'pointer events', <br> который сразу генерирует и события мыши. Браузер генерирует события по умолчанию, например на кастомный drag'n'drop <br> может активировать встроенный (при этом генерит событие pointercancel), а для сенсорных экранов много других встроенных событий. <br> Чтобы такого не случалось в css - #ball { touch-action: none } </div><div style='float:right'><img alt='mouse-events' style='width: 15rem;' src=${mouseEvents} /><br>setPointerCapture - повзоляет <br> привязать  событие к одному <br> target, например зажали мышу<br> и тянем ползунок, при этом <br> курсор может<br> слететь с ползунка</div> <hr style='clear:both'>
        <ul><li>document.addEventListener(<b>"DOMContentLoaded"</b>, ready); - html загружен, DOM построен, скрипты подгружены, но не загружены внешние ресурсы </li><li><b>window.onload</b> = function() { alert('Страница загружена');}   - все загружено <br> <b>script.onload / onerror</b> = function() {...} - срабатывает когда скрипт загружен</li><li><b>window.onerror</b> = function(message, url, line, col, errorObj) { alert(message);} -  ошибка загрузки скрипта </li><li>window.addEventListener(<b>"unload"</b>, function() {       - пользователь покидает страницу (отправляем статистику) <br> navigator.sendBeacon("/analytics", JSON.stringify(analyticsData)); }); </li><li> window.<b>onbeforeunload</b> = function() { };                                   -    пользователь собирается покинуть страницу, можно задать вопрос </li><li>document.<b>readyState</b> == 'loading' || interactive  || complete  - свойства (документ загружается/полностью прочитан/полностью загружен) </li><li> document.addEventListener(<b>'readystatechange'</b>, () => console.log(document.readyState)); - реагирует на изменения readyState </li></ul><hr> <ul><li><b>submit</b> - отправили форму</li><li> <b>focus</b> - элемент в фокусе (инпут...) </li><hr><li><b>keydown и keyup</b> – когда пользователь нажимает / отпускает клавишу.</li><li>DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.</li><hr><li><b>transitionend </b> – когда CSS-анимация завершена.</li></ul><hr><ul>
        <li><b>event.which</b> - указывает какая кнопка мыши или клавиша клавиатуры нажата (1-левая кнопка мыши, 3 - правая и т.д.)</li><li><b>clientX/clientY</b> - Координаты курсора относительно окна<br><b>pageX/pageY</b> - Координаты курсора относительно документа: </li>
        <li><b>event.altKey && event.shiftKey && event.metaKey && event.ctrlKey</b> - указывает на нажатие клавиш-модификаторов </li><li><b>event.code</b>: ""KeyA", "ArrowLeft" - указывает какая клавиша нажата в формате KeyZ (всегда одинакова не зависит от регистра)</li><li><b>event.key</b>: "A", "a" - указывает какая клавиша нажата в формате z (такая же как нажата в регистре)</li><li><b>event.keyCode</b> - код нажатой клавиши в формате 16...</li> </ul> <hr>
        <b>Всплытие</b> - срабатывание обработчиков от элемента вверх к родителям и дальше по цепочек предков. <ol><li>this (=event.<b>currentTarget</b>)  - элемент до которого дошло всплытие и на нем сработал обработчик </li><li>event.<b>target</b> – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.</li></ol><ul><li>event.<b>stopPropagation()</b> - останавливает всплытие события от элемента</li><li>event.<b>preventDefault()</b> - удаляет стандартное поведение браузера с элемента (можно в обработчике просто вернуть false, будет тоже самое)</li> <li>event.<b>stopImmediatePropagation()</b> - останавливает всплытие и срабатывание события на данном элементе</li></ul> для перехвата события на <b>стадии погружения</b> elem.addEventListener("click", e => alert('Погружение: $&#123;elem.tagName}'), <b>true</b>); <br><b>Делегирование</b> - это способ навесить обработчик на много элементов путем навешивания на их общего родителя, и обработки события в нем при всплытии через event.target.`,
        description: ""
    },
    {
        title: "Пользовательские события",
        shortDesc: `Генерация пользовательских событий <br>

        <code><span class='code-example'>let event = <b>new Event(type[, options])</b>;</span></code>   // <b>type</b> - (click, my-event...), <b>options</b> = { bubbles: true - всплывает, cancelable: true - может быть отменено действ по умолчанию, composed: true - разрешить всплытие за пределы shadowDOM }) <br><br>
        <code><span class='code-example'> let event = <b>new Event("click")</b>; <br> <b>elem.dispatchEvent</b>(event);<br><br> event.<b>isTrusted</b> </span></code> - false  для событий которые порождены кодом, true - для событий порожденных действиями пользователя <hr>
        <code><span class='code-example'>&lt;script></span></code> для генерации кастомных событий лучше использовать данный ивент, т.к. в него можно передать details (пользовательские данные) <br>
        <code><span class='code-example'>elem.addEventListener("hello", function(event) {alert(event.detail.name);}); </span></code> - UIEvent, FocusEvent, MouseEvent, WheelEvent, KeyboardEvent <br>
        <code><span class='code-example'>elem.dispatchEvent(new CustomEvent("hello", {   bubbles: true,  detail: { name: "Вася" }}));  <b>// composed:true - означает что событие будет всплывать за пределы shadowDom</b><br> &lt;/script></span></code>`,
        description: ""
    },
    {
        title: "Форма. focus/blur",
        shortDesc: `Формы <br>
        <code><span class='code-example'>&lt;<b>form</b> name="my"><br> &lt;input name="one" value="1"> <br> &lt;input name="two" value="2"> <br>&lt;/form> </span></code> <br> <b>document.forms.my || document.forms[0]</b> - выбор формы <br> <b>form.elements.one  || form.one</b> - получаем инпут из формы <br> <b>element.form</b> - возвращает форму элемента по обратной ссылке <hr>
        Select<br>
        <code><span class='code-example'>&lt;<b>select</b> id="select"><br> &lt;option value="apple">Яблоко&lt;/option> <br> &lt;option value="pear">Груша</option> &lt;/select></span></code><br> <b>select.options[2].selected = true</b>;  - способ выбрать №1 <br> <b>select.selectedIndex = 2</b>   - способ выбрать No2 <br> <b>select.value = 'banana'</b> - способ выбрать No3 <br><br>option = <b>new Option</b>(text, value, defaultSelected, selected); - создали новый опшн <br> genres.append(option); - вставили новый опшн <hr>
        
        <code><span class='code-example'>input.<b>onblur</b> = function() {         - вызывается когда элемент теряет фокус <br>if (!input.value.includes('@')) { // не email <br> input.classList.add('invalid');     } }; <br><br> input.<b>onfocus</b> = function() {   - вызывается когда элемент получает фокус
         if (this.classList.contains('invalid')) {// удаляем индикатор ошибки, т.к.         this.classList.remove('invalid');     } }; </span></code><br><br> elem.focus() и elem.blur()   - устанавливают/снимают фокус. не всплывают (их можно отловить только на стадии погружения) <br> <b>focusin и focusout</b> – такие же, как и focus/blur, но они <u>всплывают</u>. <hr> <code><span class='code-example'>&lt;li tabindex="1">Один&lt;/li> </span></code>    - включает фокусировку на любом элементе <ul><li>tabindex= 0 - включает элемент в фокусируемые но не именяет порядок</li><li>tabindex=1....3,4,5 - включает фокусировку по порядку, затем идут 0 и стандартные фокусы</li><li>tabindex=-1 - позволяет фокусироваться только програмно</li></ul><b>change</b>       - Значение инпута было изменено и потеряло focus <br>
        <b>input</b>       - Срабатывает после каждого изменении значения инпута <br><br><b>cut/copy/paste</b>      - Действия по вырезанию/копированию вставке. <br>Действие можно предотвратить. Свойство <b>event.clipboardData</b> предоставляет доступ на чтение/запись в буфер обмена... <hr> <code><span class='code-example'>&lt;form onsubmit="alert('submit!');return false"> </span></code>  - отправляет форму (по нажатию enter, нажатию на &lt;input type="submit"> или &lt;input type="image">) <br> form.<b>submit()</b> - тоже отправляет форму (событие submit не генерируется)`,
        description: "",
    },
    {
        title: "Mutation Observer",
        shortDesc: `MutationObserver – это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений. <br><b>observer.observe(node, config);</b><br><br>
        
        let config = { <br><b>childList</b>: - изменения в непосредственных детях node, <br><b>subtree</b>: - во всех потомках node, <br><b>attributes</b>: - в атрибутах node, <br>
        <b>attributeFilter</b>: - массив имён атрибутов, чтобы наблюдать только за выбранными, <br><b>characterData</b>: - наблюдать ли за node.data (текстовое содержимое), <br>
        <b>characterDataOldValue</b>: – если true, будет передавать и старое и новое значение node.data в колбэк, иначе только новое (также требуется опция characterData),<br>
        <b>attributeOldValue</b>: – если true, будет передавать и старое и новое старое значение атрибута в колбэк, иначе только новое (также требуется опция attributes). <br>}
        <ol><li>let observer = <b>new MutationObserver</b>(mutationRecords => { console.log(mutationRecords); });</li><li>observer.<b>observe</b>(elemId, { childList: true, subtree: true, characterDataOldValue: true  });</li></ol>
        
        observer.<b>disconnect</b>() - останавливает наблюдение<br>mutationRecords = observer.<b>takeRecords</b>() - получает список необработанных записей изменений для которых еще не выполнился коллбэк`,
        description: ""
    },
    {
        title: "Выделение (range/selection)",
        shortDesc: `Выделение - <b>Range</b> (общий объект для управления диапазонами выделения) <b>Selection</b> (позволяет визуально выделять и захватывать выделенное) <br> <code><span class='code-example'>&lt;p id="p">Example: &lt;i>italic&lt;/i> and &lt;b>bold&lt;/b>&lt;/p> <br><br> let range = new Range(); <br> range.<b>setStart</b>(p, 0); //берем тэг p и берем его 0-ой дочерний элемент <br>range.<b>setEnd</b>(p.querySelector('b').firstChild, 3) // заканчивается на 3 позиции первого дочернего узла тега <br> alert(range) // Example: italic <br><br>document.<b>getSelection().removeAllRanges()</b>; <br>document.<b>getSelection().addRange(range)</b>; <br><br></span></code>
        Выделение в документе представлено объектом Selection, который может быть получен как <b>window.getSelection() или document.getSelection()</b>.
        `,
        description: "<b>События</b> выделения <br>elem.<b>onselectstart</b> – когда с elem начинается выделение, например пользовать начинает двигать мышкой с зажатой кнопкой.<br> preventDefault() отменяет начало выделения.<br>document.<b>onselectionchange</b> – когда выделение изменено.(Заметьте: этот обработчик можно поставить только на document.) <hr> <b>INPUT и TEXTAREA</b> имеют свои методы, свойства и события выделения, например: <ul><li>input.<b>selectionStart</b> – позиция начала выделения (это свойство можно изменять), </li><li>input.<b>selectionEnd</b> – позиция конца выделения (это свойство можно изменять),</li><li>input.<b>selectionDirection</b> - направление выделения, одно из: «forward» (вперёд), «backward» (назад) или «none» (без направления, если, к примеру, выделено с помощью двойного клика мыши)</li><li>input.<b>onselect</b> – <b>Событие</b> срабатывает, когда начинается выделение.</li><li>input.<b>select()</b> –<b>Метод</b>выделяет всё содержимое input (может быть textarea вместо input)</li><li>и другие...</li></ul><hr>css {user-select: none} делает невыделяемым"
    },
    {
        title: "Event Loop",
        shortDesc: `Event Loop - иструмент движка JS, который проверяет <b>Call Stack (стек вызовов)</b>, и если тот пустой - идет в <b>Task Queue (очередь задач)</b> и переносит оттуда первую задачу в Call Stack, при этом пропуская вперед очередь перерендера. Задача, попавшая в Сall Stack, выполняется моментально <hr>
        <div class='event-loop'>
            <div class='web-api'><h4>WEB API</h4><br>(onClick, onScroll, setTimeout, Ajax etc.)<div class='web-pipe-bottom'></div></div>
            <div class='task-queue'><h4>TASK QUEUE</h4><br>очередь задач<div class='task-pipe-bottom'></div></div>
            <div class='render-queue'><h4>RENDER QUEUE</h4><br>(браузерная очередь рендера, примерно раз в 16мс)<div class='render-pipe-bottom'></div></div>
            <div class='call-stack'><h4>CALL STACK</h4><br>(стек вызовов)<div class='event-loop-circle'>Event Loop</div></div>
        </div>`,
        description: " С LearnJavascript <br><br> Более подробный алгоритм событийного цикла (хоть и упрощённый в сравнении со спецификацией): <br><ol><li>Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).</li><li>Исполнить все микрозадачи:</li><li>Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу</li><li>Отрисовать изменения страницы, если они есть.</li><li>Если очередь макрозадач пуста – подождать, пока появится макрозадача.</li><li>Перейти к шагу 1.</li></ol> Чтобы добавить в очередь новую макрозадачу: <br> Используйте <b>setTimeout(f)</b> с нулевой задержкой. <br> Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей. <br>Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено). <br><br>Для добавления в очередь новой микрозадачи: <br>Используйте <b>queueMicrotask(f)</b> <br>Также обработчики промисов выполняются в рамках очереди микрозадач. <br><br> События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой. <br>Поэтому <b>queueMicrotask</b> можно использовать для асинхронного выполнения функции в том же состоянии окружения."
    },
    {
        title: "Открытие окон (popup)",
        shortDesc: `<b>Открытие окон (popup)</b><br><br> <code><span class='code-example'>let params = 'scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no, <br>width=600,height=300,left=100,top=100'; <br><br> button.onclick = () => { <br> <b>window.open</b>('https://javascript.info', ‘test’, params); <br> }; <br><br> newWindow.<b>onload</b> = function() { <br> newWindow.<b>close</b>(); <br> alert(newWindow.closed); // true <br> }; <br> <br> </span></code> У попапа есть доступ к породившему его окну через свойство <b>window.opener</b> <br> Методы <b>focus()</b> и <b>blur()</b> позволяют установить или убрать фокус с попапа. Но работают не всегда. <br> События focus и blur позволяют отследить получение и потерю фокуса новым окном. Но, пожалуйста, не забывайте, что окно может остаться видимым и после blur <hr>
        <code><span class='code-example'>&lt;<b>iframe</b> src="https://example.com" id="iframe">&lt;/iframe><br><br>&lt;script><br><b>iframe.onload</b> = function() { <br> let iframeWindow = <b>iframe.contentWindow</b>;  //объект window внутри айфрейм<br>let doc = <b>iframe.contentDocument</b>;                //объект document  внутри айфрейм <br> let href = <b>iframe.contentWindow.location.href</b>; //текущий путь <br><br><b>iframe.contentWindow.location</b> = '/'; // OK <br><br> iframe.onload = null; // уберём обработчик, чтобы не срабатывал после изменения location <br> };<br> &lt;/script></span></code> <hr> Окна могут общаться если они с одного домена, или домена второго уровня (при этом у обоих document.domain <b>=</b> 'site.com';) <br><br>&lt;iframe <b>sandbox="allow-same-origin"</b> src="/" /> - включает ограничение разных доменов <br><br> <hr>для общения окон: <br><br> <code><span class='code-example'>В первом окне: <br><br>&lt;iframe src="http://example.com" name="example">&lt;script> <br>let win = window.frames.example; <br>win.<b>postMessage("message", "*");</b><br>&lt;/script> <br><br> Во втором окне:<br><br> window.addEventListener(<b>"message"</b>, function(event) { <br> if (event.origin != 'http://javascript.info') { <br> // что-то пришло с неизвестного домена. Давайте проигнорируем это <br> return; <br> } <br> alert( "received: " + event.data ); <br><br> // can message back using event.source.postMessage(...) <br> });`
    },
    {
        title: "Типизированные массивы",
        shortDesc: `Типизированные массивы позволяют получить хорошую производительность при работе с файлами, аудио,звуком, сетевыми пакетами и т.д., так как они работают только с числовыми значениями <br> Работа с этими массивами разбита на несколько классов: <ul><li>ArrayBuffer - выделенная память</li><li>DataView, Uint8Array, Blob, File, Uint16Array, Float64Array ... и др. - Доступ к этой памяти</li></ul><hr> На примере fetch, со строкой состояния загрузки посмотрим как это работает<br><br><code><span class='code-example'>let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100'); <br><br> const reader = response.body.getReader();      // <b>получаем доступ к потоку вместо response.json()</b><br><br> <b>Шаг 2: получаем длину содержимого ответа</b><br> const contentLength = +response.headers.get('Content-Length'); <br><br>
        <b>Шаг 3: считываем данные:</b><br><br>let receivedLength = 0;     <b>// количество байт, полученных на данный момент</b> <br>let chunks = [];    <b>// массив полученных двоичных фрагментов (составляющих тело ответа)</b> <br>while(true) { <br>const {done, value} = await reader.read(); <br>if (done) { <br>break; <br>} <br>chunks.push(value); <br>receivedLength += value.length; <br><br>console.log('Получено $&#123;receivedLength} из $&#123;contentLength}') <hr><b>Шаг 4: соединим фрагменты в общий типизированный массив Uint8Array</b> <br><br>let chunksAll = new <b><u>Uint8Array</u></b>(receivedLength); // <b>Создаем типизированный массив заданной длины</b><br>let position = 0; <br>for(let chunk of chunks) { <br>chunksAll.<b><u>set</u></b>(chunk, position); // <b>Заполняем байтовый массив полученными фрагментами файла, каждый занимает свою часть массива, начиная с position</b><br>position += chunk.length; <br>  }<br>}<br> <br><b>Шаг 5: декодируем Uint8Array обратно в строку</b><br>let result = new <b>TextDecoder("utf-8").decode(chunksAll)</b>; <br><br>let commits = JSON.parse(result);<br> alert(commits[0].author.login);
`,
        descrition: ""
    },
    {
        title: "fetch",
        shortDesc: `<code><span class='code-example'>let response = <b>await fetch</b>(url, options); // завершается с заголовками ответа <br> let result = await response<b>.json()</b>; // читать тело ответа в формате JSON <br><br> Или, без await: <br><br> <b>fetch</b>(url, options) <br>.then(response => response.json()) <br> .then(result => /* обрабатываем результат */) </span></code><hr> Параметры ответа: <br><ul><li>response.<b>status</b> – HTTP-код ответа,</li><li>response.<b>ok</b> – true, если статус ответа в диапазоне 200-299.</li><li>response.<b>headers</b> – похожий на Map объект с HTTP-заголовками.</li></ul>Методы для получения тела ответа:<br>
        <ul><li>response.<b>text</b>() – возвращает ответ как обычный текст,</li><li>response.json() – преобразовывает ответ в JSON-объект,</li><li>response.<b>formData</b>() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),</li><li>response.<b>blob</b>() – возвращает объект как Blob (бинарные данные с типом),</li><li>response.<b>arrayBuffer</b>() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),</li></ul>Опции fetch, которые мы изучили на данный момент:<br><ul><li>method – HTTP-метод,</li><li>headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),</li><li>body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.</li>`,
        description: ""
    }, 
    {
        title: "formData",
        shortDesc: `FormData <br>
        <code><span class='code-example'>&lt;form id="formElem"><br>&lt;input type="text" name="firstName" value="John"><br> Картинка: &lt;input type="file" name="picture" accept="image/*"><br>&lt;input type="submit"><br>&lt;/form><br><br>&lt;script><br>formElem.onsubmit = async (e) => {<br> e.preventDefault();<br><br> let response = await <b>fetch</b>('/article/formdata/post/user-avatar', {<br> method: 'POST',<br> body: <b>new FormData</b>(formElem)<br> }); <br><br>let result = await response.json(); <br> alert(result.message); <br> }; <br> &lt;/script> <br><br></span></code>
        Мы можем создать такой объект уже с данными, передав в конструктор HTML-форму – new FormData(form), или же можно создать объект вообще без формы и затем добавить к нему поля с помощью методов:<br>
        <ul><li>formData.<b>append</b>(name, value)</li>
        <li>formData.<b>append</b>(name, blob, fileName)</li>
        <li>formData.<b>set</b>(name, value)</li>
        <li>formData.<b>set</b>(name, blob, fileName)</li></ul>
        Отметим две особенности:<br>
        Метод <u>set удаляет предыдущие поля с таким же именем, а append – нет</u>. В этом их единственное отличие.<br>
        Чтобы послать файл, нужно использовать синтаксис с тремя аргументами, в качестве третьего как раз указывается имя файла, которое обычно, при &lt;input type="file">, берётся из файловой системы. <br><br>
        Другие методы:<br>
        formData.<b>delete</b>(name)<br>
        formData.<b>get</b>(name)<br>
        formData.<b>has</b>(name)
        `,
        description: ""
    },
    {
        title: "Прерывание fetch и других async",
        shortDesc: "Для прерывания fetch и других асинхронных задач существует AbortController <br><br><code><span class='code-example'>let controller = <b>new AbortController</b>();<br>let signal = controller.<b>signal</b>; //Данный сигнал позволяет отслеживать прерывание задач контроллером <br> <b>signal.addEventListener('abort'</b>, () => alert('отмена!')); // срабатывает при вызове controller.abort() <br>controller.abort(); // отмена! <br>alert(signal.aborted); // true </span></code><hr> <h4>Прерываем fetch и другие асинхронные задачи</h4><code><span class='code-example'>let urls = [...];<br> let controller = new AbortController();<br><br>let ourJob = new Promise((resolve, reject) => { // наша задача <br> ... <br> <b>controller.signal.addEventListener('abort'</b>, reject); <br>}); <br><br> let fetchJobs = urls.map(url => fetch(url, { <b>// много запросов fetch, или же один </b><br>signal: controller.signal <b>// fetch умеет работать с сигналом</b> <br> })); <br><br> let results = await Promise.all([...fetchJobs, ourJob]); </span></code> // ожидать выполнения нашей задачи и всех запросов <br>// вызов откуда-нибудь ещё: <br><br>// controller.abort() прервёт все вызовы fetch и наши задачи",
        description: ""
    },
    {
        title: "crossorigin",
        shortDesc: `Запросы бывают <ul><li>простые (GET,POST,HEAD)<br>С простыми заголовками: <ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type: application/x-www-form-urlencoded, multipart/form-data или text/plain.</li></ul></li><li>Непростые</li></ul> При отправке непростого запроса, отправлется запрос preflight (OPTIONS), для получения разрешения на отправку запроса.Браузер ставит origin автоматически в запросе (напр.https://javascript.info), и заголовки Access-Control-Request-Method Access-Control-Request-Headers, чтобы понять какие разрешены Методы И Хедеры. Сервер, в свою очередь, отвечает заголовком Access-Control-Allow-Origin (в нем будет наш origin или  *) и другими хедерами <br><br> Чтобы отправлять запрос с авторизационными данными из js, <br><code><span class='code-example'>fetch('http://another.com', { <br><b>credentials: "include"</b><br>});`,
        description: ""
    },
    {
        title: "URL",
        shortDesc: "URL удобный интерфейс для создания и разбора url адресов <br> let url = <b>new URL</b>('https://javascript.info/profile/admin'); <br> let newUrl = <b>new URL</b>('tester', url);  (если два аргумента, то первый это добавочный путь а второй основной, иначе первый - основной)<br> разбивает url на компоненты, доступ к которым: <ul><li>alert(url.<b>protocol</b>); // https: </li><li>alert(url.<b>host</b>);     // javascript.info </li><li> alert(url.<b>pathname</b>);</li></ul> Для доступа к параметрам, записанным в url строку, мы можем обращаться к url.<b>searchParams</b> <ul><li><b>append</b>(name, value) – добавить параметр по имени</li><li><b>delete</b>(name) – удалить параметр по имени</li><li><b>get</b>(name) – получить параметр по имени,</li><li><b>getAll</b>(name) – получить все параметры с одинаковым именем name (такое возможно, например: ?user=John&user=Pete),</li><li><b>has</b>(name) – проверить наличие параметра по имени</li><li><b>set</b>(name, value) – задать/заменить параметр</li><li><b>sort()</b> – отсортировать параметры по имени, используется редко,</li><li>…и является перебираемым, аналогично Map</li></ul><hr> Объект url автоматиченски кодирует строки, и вместо них вставляет разрешенные символы, но бывает мы хоти просто написать url строкой, тогда нам нужно самим поаботиться о кодировании: <ul><li>let url = <b>encodeURI</b>('http://site.com/привет'); – кодирует URL-адрес целиком.</li><b>decodeURI</b> – декодирует URL-адрес целиком. </li><li><b>encodeURIComponent</b>– кодирует компонент URL, например, параметр, хеш, имя пути и т.п.</li><li><b>decodeURIComponent</b> – декодирует компонент URL.</li></ul>",
        description : ""
    },
    {
        title: "XMLHttpRequest",
        shortDesc: "XMPLHttpReauest является более старым, встроенным в браузером, способом оотправки данных на сервер без перезагрузки страницы, чем Fetch.<code><span class='code-example'><br>xhr.open(method, URL, [async, user, password]) <br> xhr.send(formData)  - formData (или другой body) это тело запроса, для POST и других <br> xhr.abort(); - прерывает запрос</span></code> <br>В отличие от fetch можно отслеживать прогресс отправки файлов на сервер. <br><br><code><span class='code-example'> let xhr = <b>new XMLHttpRequest</b>();<br> xhr.<b>open</b>('GET', '/my/url'); <br> xhr.<b>send</b>();<br><br>xhr.<b>onload</b> = function() { <br> if (xhr.<b>status</b> != 200) { // HTTP ошибка? <br>alert( 'Ошибка: ' + xhr.status);         // обработаем ошибку <br> return; } <br> // получим ответ из xhr.response <br>}; <br><br> xhr.<b>onprogress</b> = function(event) { <br>// выведем прогресс <br>alert(`Загружено $&#123;event.loaded} из $&#123;event.total}`); <br>}; <br><br> xhr.<br> onerror </b> = function() { // обработаем ошибку, не связанную с HTTP (например, нет соединения) </span></code><br>}; <hr> События запроса: <ul><li><b>loadstart</b> – начало запроса.</li><b>progress</b> – прибыла часть данных ответа, тело ответа полностью на данный момент можно получить из свойства responseText.</li><li><b>abort</b> – запрос был прерван вызовом xhr.abort().</li><li><b>error</b> – произошла ошибка соединения, например неправильное доменное имя. Событие не генерируется для HTTP-ошибок как, например, 404.</li><li><b>load</b> – запрос успешно завершён.</li><li><b>timeout</b> – запрос был отменён по причине истечения отведённого для него времени (происходит, только если был установлен таймаут).</li><li><b>loadend</b> – срабатывает после load, error, timeout или abort.</li></ul> Если необходимо отслеждивать процесс именно отправки данных насервер, необходимо все теже события отслеживать на объекте <b>xhr.upload</b>",
        description : ""
    },
    {
        title: 'Длинные опросы',
        shortDesc: "Длинные опросы: <ul><li>Запрос отправляется на сервер.</li><li>Сервер не закрывает соединение, пока у него не возникнет сообщение для отсылки.</li><li>Когда появляется сообщение – сервер отвечает на запрос, посылая его.</li><li>Браузер немедленно делает новый запрос.</li></ul>Частые опросы: <ul><li>Например каждые 10 секунд клиент отправляет запрос на сервер и спрашивает есть ли новые сообщения</li><li>Сервер отвечает, что клиент онлайн и отправляет пакет сообщений</li> <hr> Длинный запрос пример: <br><code><span class='code-example'>async function subscribe() { <br>let response = await fetch('/subscribe');<br><br> if (response.status == 502) {  // Статус 502 - это таймаут соединения; // возможен, когда соединение ожидало слишком долго <br> await subscribe(); // восстановили соединение <br><br> } else if (response.status != 200) { // Какая-то ошибка, покажем её <br> showMessage(response.statusText); <br>await new Promise(resolve => setTimeout(resolve, 1000)); // Подключимся снова через секунду. <br>await subscribe(); <br><br>} else { <br>let message = await response.text();      // Получим и покажем сообщение <br>showMessage(message); <br>await subscribe();    // И снова вызовем subscribe() для получения следующего сообщения <br> } <br>} <br>subscribe();</span></code>",
        description : ""
    },
    {
        title: "WebSocket",
        shortDesc: `WebSocket - (ws,wss) это протокол, который позволяет серверу и клиенту обмениваться данными (message), в виде пакетов, поддерживая при этом постоянное подключение. <br>
        <code><span class='code-example'>let socket = <b>new WebSocket</b>("wss://javascript.info/article/websocket/demo/hello"); <br><br>socket.<b>onopen</b> = function(e) {<br>alert("[open] Соединение установлено, отправим данные на сервер"); <br>socket.<b>send</b>("Меня зовут Джон");<br>};<br><br>
        socket.<b>onmessage</b> = function(event) {<br>alert('[message] Данные получены с сервера: $&#123;event.data}'); <br>};<br><br>socket.<b>onclose</b> = function(event) {<br>if (event.<b>wasClean</b>) {alert('[close] Соединение закрыто чисто, код=$&#123;event.code} причина=$&#123;event.reason}');<br>} else {<br>alert('[close] Соединение прервано. Например, сервер убил процесс или сеть недоступна // обычно в этом случае event.code 1006'); <br>}<br>};<br><br>
        socket.<b>onerror</b> = function(error) {<br> alert('[error] $&#123;error.message}');<br> };</span></code> <hr> Фреймы websocket'ов бывют таких видов: <b>текстовые фреймы, бинарные фреймы, пинг-понг, фреймы закрытия</b><br> Для закрытия соединения socket.<b>close([code], [reason])</b>  // code 1000 - нормальное закрытие</b><br><br> Состояние соединения можно посмотреть  socket.<b>readyState</b> // <br>(0 – «CONNECTING»: соединение ещё не установлено, 1- «OPEN»: обмен данными, <br>2 – «CLOSING»: соединение закрывается, 3 – «CLOSED»: соединение закрыто.) <br><br>wss://ws.site.com – поддомен, который ведёт к WebSocket-серверу;`,
        description: ""
    },
    {
        title: "Server Sent Events",
        shortDesc: "Спецификация Server-Sent Events описывает встроенный класс <b>EventSource</b>. Похож на websocket, но <ul><li> данные посылает только сервер</li><li> использует обычный протокол http</li><li>может отрправлять только текст</li></ul> <br> Чтобы начать получать данные необходимо: <ul><li>просто создать new EventSource(url)</li><li>Браузер установит соединение с url и будет поддерживать его открытым, ожидая события.</li><li>Сервер должен ответить со статусом 200 и заголовком Content-Type: text/event-stream</li><li>Сервер поддерживает соединение открытым и отправлет сообщения</li></ul> <code><span class='code-example'>let eventSource = <b>new EventSource</b>('/events/subscribe', <br> {withCredentials: true} // Авторизационные данные. Необязательный второй аргумент<br>); <br><br>eventSource.<b>onmessage</b> = function(event) {<br> console.log('Новое сообщение', event.data);<br> // этот код выведет в консоль 3 сообщения, из потока данных выше <br> }; <hr>// или eventSource.addEventListener('message', ...)</span></code> <br><br> При разрыве соединения автоматически переподключается <ul><li>Если сервер хочет остановить попытки переподключения, он должен ответить со статусом 204.</li><li>Если браузер хочет прекратить соединение, он может вызвать <b>eventSource.close</b>()</li></ul><b>readyState</b> - Текущее состояние подключения: <br>EventSource.CONNECTING (=0), EventSource.OPEN (=1) или EventSource.CLOSED (=2).<br><b>lastEventId</b> - id последнего полученного сообщения. При переподключении браузер посылает его в заголовке Last-Event-ID.<br><br>Методы: <br><b>close()</b> - Закрывает соединение. <br><br>События <br><b>message</b> - Сообщение получено, переданные данные записаны в event.data. <br><b>open</b> - Соединение установлено. <br><b>error</b> -  В случае ошибки, включая как потерю соединения, так и другие ошибки в нём. <br>Мы можем обратиться к свойству readyState, чтобы проверить, происходит ли переподключение. <br><br>Сервер может выставить собственное событие с помощью <b>event</b>:. Такие события должны быть обработаны с помощью addEventListener, а не on<event>.",
        description :""
    }, {
        title: "document.cookie",
        shortDesc: `Cookie - это небольшие строковые данные, которые хранятся в браузере.<br><br>при входе на сайт, сервер отправляет в ответ HTTP-заголовок Set-Cookie со специальным уникальным идентификатором сессии (session identifier) и куки устанавливаются в браузер.<br>Отправляя запрос на сервер браузер отправляет HTTP-header Cookie <hr><b>document.cookie || document.cookie = 'user=John';</b> - доступ к куки с данного сайта<br> Все куки записываются через ; одной строкой. <br><br> Для правильного форматирования куки <br><code><span class='code-example'>document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);</span></code><br><br> У куки есть настройки: <br> <code><span class='code-example'>document.cookie = 'user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT'</span></code> <ul><li><b>path=/mypath</b> - URL-префикс пути, куки будут доступны для страниц под этим путём. Должен быть абсолютным</li><li><b>domain=site.com</b> - если явно указан домен, то куки видно и на поддоменах. Но не все так просто, есть ряд ограничений</li><li><b>expires</b>=Tue, 19 Jan 2038 03:14:07 GMT - // let date = new Date(Date.now() + 86400e3); document.cookie = 'user=John; expires=' + date; </li><li>document.cookie = 'user=John; <b>max-age=3600</b>'; - время жизни куки в секундах</li><li>document.cookie = 'user=John; <b>secure</b>'; - указывает что куки следует передавать только по https:// </li><li>samesite - защита от XSRF атак</li><li>httpOnly - доступ к куки только из html, из js запрещен</li></ul> <hr><code><span class='code-example'>function <b>getCookie</b>(name) { <br>let matches = document.cookie.match(new RegExp( <br> '(?:^|; )' + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'<br>)); <br> return matches ? decodeURIComponent(matches[1]) : undefined; <br>} <hr> 
        function <b>setCookie</b>(name, value, options = {}) {<br> options = {<br> path: '/',<br> // при необходимости добавьте другие значения по умолчанию<br> ...options<br> };<br><br> if (options.expires instanceof Date) {<br> options.expires = options.expires.toUTCString();<br> }<br><br> let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);<br><br> for (let optionKey in options) {<br> updatedCookie += "; " + optionKey;<br> let optionValue = options[optionKey];<br> if (optionValue !== true) {<br> updatedCookie += "=" + optionValue;<br> }<br> }<br><br> document.cookie = updatedCookie;<br> }<br><br> // Пример использования:<br> setCookie('user', 'John', {secure: true, 'max-age': 3600});<hr>
        function <b>deleteCookie</b>(name) {<br><u>setCookie</u>(name, "", {<br> 'max-age': -1 <br> })<br> }`,
        description: ""
    },
    {
        title: "LocalStorage, sessionStorage",
        shortDesc: `В отличие от cookie не отправляется на сервер с каждым запросом, может хранить минимум 2 мб данных, доступ только из JS, сервер никак не достанет до локалстора. <br><table><thead><tr><td><b>localStorage</b></td><td><b>sessionStorage</b></td></tr></thead><tbody></tbody><tr><td>Совместно используется между всеми вкладками и окнами с одинаковым источником</td><td>Разделяется в рамках вкладки браузера, среди ифреймов из того же источника</td></tr><tr><td>«Переживает» перезапуск браузера</td><td>«Переживает» перезагрузку страницы (но не закрытие вкладки)</td></tr></tbody></table> <br> Запись и чтение данных из storage осуществляется 2 способами: <ol><li>localStorage.<b>setItem</b>('test', 1); <br> alert( localStorage.<b>getItem</b>('test') ); // 1 </li><li>localStorage<b>.</b>test = 2; /// установить значение для ключа <br> alert( localStorage.test );     // 2  // получить значение по ключу <br> <b>delete</b> localStorage.test;        // удалить ключ </li></ol> <hr> Перебор localStorage: (т.к. неитерируемый) <code><span class='code-example'> <ul><li> for(let i=0; i<localStorage.length; i++) { <br>let key = localStorage.key(i); <br> alert('$&#123;key}: $&#123;localStorage.getItem(key)}'); } </li><li>for(let key in localStorage) {<br>if (!localStorage.hasOwnProperty(key)) { <br> continue;    // <b>пропустит такие ключи, как "setItem", "getItem" и так далее</b> } <br> alert('$&#123;key}: $&#123;localStorage.getItem(key)}');} </li><li>let keys = Object.keys(localStorage); <br>for(let key of keys) { <br> alert('$&#123;key}: $&#123;localStorage.getItem(key)}');}</li></ul></span></code><hr> Сохранение объекта в storage: <br><br> <code>sessionStorage.user = JSON.stringify({name: "John"}); <br> let user = JSON.parse( sessionStorage.user ); // немного позже</code> <hr> Для отслеживания событий по работе с storage: <br><code><span class='code-example'>window.onstorage = event => { <br> if (event.key != 'now') return; <br> alert(event.key + ':' + event.newValue + " at " + event.url); <br>};</span></code> <hr> событие одно и то же для sessionStorage и localStorage, поэтому event.storageArea ссылается на то хранилище, которое было изменено <hr> Все методы стора: <br><br><b>setItem</b>(key, value) – сохранить пару ключ/значение. <br><b>getItem</b>(key) – получить данные по ключу key.<br><b>removeItem</b>(key) – удалить значение по ключу key. <br><b>clear</b>() – удалить всё. <br><b>key</b>(index) – получить ключ на заданной позиции. <br><b>length</b> – количество элементов в хранилище. <br><br>
        Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событие storage не срабатывает.<br> Событие storage:<br> Срабатывает при вызове setItem, removeItem, clear.<br> Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.<br> Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).`, 
        description: ""
    },
    {
        title: "Indexed DB",
        shortDesc: `IndexedDB – это встроенная в браузер база данных, более мощная, чем localStorage. (No SQL - нельзя sql запросы, нереляционная - нет зависимостей, нет таблиц, все объектно-ориентрованно) <br><br> Часто используется при девелопмент разработке, а также в работе расширений для браузеров. <br><div style="float: right"><img style="width: 50rem;" alt="indexedDb" src=${indexedDB} /></div><div>
        Использование можно описать в нескольких фразах: <ol><li> Подключить обёртку над промисами, например idb.</li><li>Открыть базу данных: idb.<b>openDb</b>(name, version, onupgradeneeded)<ul><li>Создание хранилищ объектов и индексов происходит в обработчике onupgradeneeded.</li><li>Обновление версии – либо сравнивая номера версий, либо можно проверить что существует, а что нет.</li></ul></li><li>Для запросов:<ul><li>Создать транзакцию db.transaction('books') (можно указать readwrite, если надо).</li><li>Получить хранилище объектов transaction.objectStore('books').</li></ul></li><li>Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.<ul><li>Для поиска по любому полю объекта создайте индекс.</li></ul></li><li>Если данные не помещаются в памяти, то используйте курсор.</li></ol>
        <code><span class='code-example'>&lt;!doctype html> <br>&lt;script src="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/<b>idb</b>.min.js"></script><br>&lt;button onclick="addBook()">Добавить книгу</button><br>&lt;button onclick="clearBooks()">Очистить хранилище</button><br>&lt;p>Список книг:</p><br>&lt;ul id="listElem"></ul><hr>&lt;script><br>
        let db;<br>init();<br><br>async function init() {<br>db = await idb.<b>openDb</b>('booksDb', 1, db => {           //Открыли базу данных <br>db.createObjectStore('books', {keyPath: 'name'}); <br>});<br><br>list();<br>}<hr>async function list() { <br>let tx = db.<b>transaction</b>('books');   // Создали транзакцию<br> let bookStore = tx.objectStore('books');  // получили хранилище объектов <br><br>let books = await bookStore.getAll();if (books.length) {<br>listElem.innerHTML = books.map(book => '&lt;li><br>название: $&#123;book.name}, цена: $&#123;book.price} <br>&lt;/li>').join('');<br>} else {<br>listElem.innerHTML = '&lt;li>Книг пока нет. Пожалуйста, добавьте книги.&lt;/li>'<br>}<br>
        }<hr>async function clearBooks() {<br>let tx = db.<b>transaction</b>('books', 'readwrite');<br>await tx.<b>objectStore</b>('books').clear();<br>await list();<br>}<hr>async function addBook() {<br>let name = prompt("Название книги");<br>let price = +prompt("Цена книги");<br><br>let tx = db.<b>transaction</b>('books', 'readwrite');<br><br>try {<br>await tx.<b>objectStore</b>('books').add({name, price});<br>await list();<br>} catch(err) {<br>if (err.name == 'ConstraintError') {<br>alert("Такая книга уже существует");<br>await addBook();<br>} else {<br>throw err;<br>}<br>}<br>}<hr>window.addEventListener('<b>unhandledrejection</b>', event => {<br>alert("Ошибка: " + event.reason.message);<br>});<br><br>&lt;/script></span></code></div>`,
        description:""
    },
    {
        title: "Анимация",
        shortDesc: `Кривая безье - линия, проведенная по опорным точкам. Кривые Безье используются для рисования, Canvas, шрифты, наложения темпа анимации или траектории и др.<br> Когда завершается анимация срабатывает событие <b>transitionend</b><br><br> <h4>В CSS за анимацию</h4> отвечает свойство transition, или его подсвойства <ul><li><b>transition-property</b> – свойство перехода </li><li><b>transition-duration</b> – продолжительность перехода</li><li><b>transition-timing-function</b> – временная функция перехода</li><li><b>transition-delay</b> – задержка начала перехода</li></ul><code><span class='code-example'>#growing { <br> <b>transition</b>: font-size 3s, color 2s; <br> } <br><br> &lt;script> growing.onclick = function() { <br> this.style.fontSize = '36px';<br>this.style.color = 'red'; <br> }; <br>&lt;/script></span></code><hr> Также css анимация бывает с использованием ключевых кадров: <br><code><span class='code-example'>&lt;style> <b>@keyframes</b> go-left-right {        /* объявляем имя анимации: 'go-left-right' */ <br>from { left: 0px; }             /* от: left: 0px */ <br> to { left: calc(100% - 50px); } /* до: left: 100%-50px */<br>} <br><br>.progress {<br> animation: go-left-right 3s infinite alternate;<br> <b>применить анимацию 'go-left-right' на элементе продолжительностью 3 секунды <br> количество раз: бесконечно (infinite) менять направление анимации каждый раз (alternate)</b> <br>position: relative; <br>border: 2px solid green; <br>width: 50px;<br>height: 20px;<br>background: lime;<br>}<br>&lt;/style></span></code> <hr> <h4>Анимация в JS</h4><ol><li><code><span class='code-example'>
        let start = Date.now(); <b>// запомнить время начала</b> <br>let timer = setInterval(function() {   <br> let timePassed = Date.now() - start;      <b>// сколько времени прошло с начала анимации?</b> <br>if (timePassed >= 2000) {<br>clearInterval(timer); <b>// закончить анимацию через 2 секунды</b> <br>return;<br>}<br><br> draw(timePassed);    <b>// отрисовать анимацию на момент timePassed, прошедший с начала анимации</b> <br> }, 20);<br><br><b> в то время как timePassed идёт от 0 до 2000  left изменяет значение от 0px до 400px</b><br>function draw(timePassed) { <br>train.style.left = timePassed / 5 + 'px'; <br>}</li><li>let requestId = <b>requestAnimationFrame</b>(callback) (функция, которая решает проблемы торможения и нагрузки на CPU) <br> // отмена запланированного запуска callback <br><b>cancelAnimationFrame</b>(requestId) <br><br><code><span class='code-example'>var adiv = document.getElementById('mydiv') <br>var leftpos = 0 <br><br> function movediv(timestamp){ <br> leftpos += 5 <br> adiv.style.left = leftpos + 'px' <br><b>requestAnimationFrame</b>(movediv)  <b>// call requestAnimationFrame again to animate next frame</b> }<br> <br>requestAnimationFrame(movediv); </span></code></li></ol>`
    },
    {
        title: "Пользовательские элементы",
        shortDesc: `Мы можем создавать свои html элементы. Пользовательские элементы бывают: <ol><li><b>Автономные</b> – новые теги, расширяющие HTMLElement.<br><br><code><span class='code-example'>class MyElement extends HTMLElement {<br>constructor() { super(); /* ... */ } <br>connectedCallback() { /* ... */ }   <b>// вызывается браузером каждый раз при добавлении элемента в документ</b> <br>disconnectedCallback() { /* ... */  } <b>// вызывается браузером каждый раз при удалении элемента из документа</b> <br>static get observedAttributes() { return [/* <b>массив имён атрибутов для отслеживания их изменений</b> */]; }<br>attributeChangedCallback(name, oldValue, newValue) { /* ... */ } <b>// вызывается при изменении одного из перечисленных выше атрибутов</b><br>adoptedCallback() { /* ... */ }  <b> // вызывается, когда элемент перемещается в новый документ // (происходит в document.adoptNode, используется очень редко) </b><br>}<br>
        customElements.define('my-element', MyElement); <br>/* &lt;my-element> */<br></span></code></li><li><b>Модифицированные встроенные элементы</b> – расширения существующих элементов. <br>Требуют ещё один аргумент в .define и атрибут is="..." в HTML: <br><br><code><span class='code-example'>class MyButton extends HTMLButtonElement { /*...*/ } <br>customElements.define('my-button', MyElement, {extends: 'button'}); <br>/* &lt;button is="my-button"> */ </span></code></li></ol>`,
        description: ""
    },
    {
        title: "Shadow DOM",
        shortDesc: `Shadow DOM  это инкапсулированная (скрытая) DOM структура HTML элементов, она изолирована и к ней нет доступа из главного документа. <br><br> Для теневого Dom работают только свои стили, стили документа не работают с ним. <br><br><code><span class='code-example'>&lt;div id='elem'>&lt;/div> <br><br> &lt;script><br>elem.<b>attachShadow({mode: 'open'})</b>  // (mode:open - теневой дом досутепн через elem.shadowRoot, close - null);<br>elem.shadowRoot.innerHTML = ' <br>&lt;style> p { font-weight: bold; } &lt;/style>            // у теневого дерева свои стили (2)<br>&lt;p>Hello, John!&lt;/p><br>';<br><br>alert(document.querySelectorAll('p').length); // 0 <br>alert(elem.shadowRoot.querySelectorAll('p').length); // 1   // &lt;p> виден только запросам внутри теневого дерева <br>&lt;/script>`,
        description: ""
    },
    {
        title: "Template",
        shortDesc: `Template - Встроенный элемент для хранения шаблона HTML. Браузер полностью игнорирует его содержимое, проверяя лишь синтаксис, но мы можем использовать этот элемент в JavaScript, чтобы создать другие элементы. <br><br> <code><span class='code-example'><b>&lt;template</b> id="tmpl"><br>
        &lt;script><br>
          alert("Привет");<br>
          &lt;/script><br>
          &lt;div class="message">Привет, Мир!&lt;/div><br>
          <b>&lt;/template></b><br><br>
      
          &lt;script><br>
        let elem = document.createElement('div');<br><br>
      
        // Клонируем содержимое шаблона для того, чтобы переиспользовать его несколько раз<br>
        elem.append(tmpl<b>.content.cloneNode(true)</b>);<br><br>
      
        document.body.append(elem);<br>
        // Сейчас скрипт из &lt;template> выполнится<br>
        &lt;/script></span></code>`,
        description: ""
    },
    {
        title: "Slot'ы",
        shortDesc: `Slot используется для вставки в теневой (shadow) DOM элементов, записанных через светлый(light) DOM. Тоесть если кастомный элемент меню ожидает принять пункты меню, то оформляем их как слоты, а далее через обычный html вставляем их в кастомный элемент. Слоты позволяют показать элементы светлого DOM на заданных местах в теневом DOM. <br><br> <code><span class='code-example'>&lt;script><br> customElements.define('user-card', class extends HTMLElement { <br>connectedCallback() { <br> this.<b>attachShadow</b>({mode: 'open'}); <br> this.shadowRoot.innerHTML = ' <br> &lt;div>Имя: <br> <b>&lt;slot name='username'></slot></b><br>&lt;/div><br>&lt;div>Дата рождения: <br> <b>&lt;slot name='birthday'></slot></b> <br> &lt;/div> <br> &lt;fieldset> <br> &lt;legend>Другая информация&lt;/legend> <br> <b>&lt;slot>&lt;/slot></b>  <b>// Слот без имени, выступает слотом по умолчанию и собирает все неподписанные вставленные элементы в себя</b> <br> &lt;/fieldset> <br>';<br> }<br>});<br>&lt;/script></span></code> <hr> Использование: <br><code><span class='code-example'>&lt;user-card> <br>&lt;div>Я люблю плавать.</div><br>&lt;span slot='username'>Иван Иванов&lt;/span><br>&lt;span slot='birthday'>01.01.2001&lt;/span><br>&lt;div>...И играть в волейбол!</div> <br> &lt;/user-card></span></code> <br><br><br><div><img  style='width: 50rem;' alt='slot-example' src=${slotExample}/></div><br>  Для отслеживания изменений в слотах - <code><span class='code-example'>this.shadowRoot.firstElementChild.addEventListener('<b>slotchange</b>',<br> e => alert("slotchange: " + e.target.name) <br> );</span></code><ul><li>slot.assignedNodes/Elements() – возвращает узлы/элементы, которые находятся внутри slot.</li><li>node.assignedSlot – обратный метод, возвращает слот по узлу.</li><li>внутри css slota :host {} ссылка на сам элемент</li><li>::slotted(селектор) позволяет стилизовать сами слотовые элементы, но не их дочерние элементы.</li> </ul>`,
        description: ""
    },
    {
        title: "Общее",
        shortDesc: `<ul><li>px - абсолютная величина, для точного задания размера</li><li>em - размер относительно шрифта родителя</li><li>rem - размер относительно шрифта <html></li><li>% – относительно такого же свойства родителя (как правило, но не всегда)</li><li>vw, vh, vmin, vmax – относительно размера экрана.</li></ul><br>Display: <ul><li>none - элемент не показывается, вообще. Будто его нет</li><li>block - блочная модель, элемент занимает всю ширину родителя, распологаются вертикально один за другим, если нет float</li><li>inline - Элементы располагаются на той же строке, последовательно. Ширина и высота по содержимому</li><li>inline-block - распологается также в строке, по содержимому, но работает width/height (работает vertical-align)</li><li>table - табличный алгоритм расчет</li><li> table-cell - тоже табличный алгоритм, но можно без всей таблицы (работает vertical-align: middle)</li><li>list-item - какбудто список (работает list-style:inside square)</li><li> flex - позволяет использовать flex-box внутри</li></ul> Float: вынимает элемент из потока и смещает (left, right, none, inherit). Делает элемент сразу блочным. Если нужно дальше разместить элемент чтобы он не обтекал float, то div style="clear:both" (clear - говорит что элементу запрещено обтекать флоаты с обеих сторон)<br><br> Posititon: <ul><li>static - обычное позицинирование</li><li>relative - смещается относительно своего расположения</li><li>absolute - смещается относительно ближайшего позиционированного родителя или window</li><li>fixed - позиционирование относительно окна браузера</li></ul> Центрирование: <ol><li>Горизонтальное <ul><li>для inline - text-align</li><li>для блока - margin: auto</li></ul></li><li>Вертикальное <ul><li>position: absolute; top: 50% - (50% elem. height)</li><li>Можно указать line-height как и высоту элемента, тогда он будет по средине</li><li>Сделать элемент родитель display:table-cell и отцентровать в нем vertical-align: 
        middle</li><li>display: flex, justify-content: center; /*Центрирование по горизонтали*/, align-items: center; /* По вертикали */</ul></li></ol> <br> Line-height: высота строки, можно задать множителем (1.5 - полтора текущего шрифта,  или можно фиксированно другими величинами)<br>font-size - размер шрифта <br><br>white-space (поведение строк) <ul><li>normal - стандартное</li><li>pre - пробелы сохраняются, текст переносится если есть явные переносы</li><li>nowrap - не сохраняет пробелы, не переносит строки</li><li>pre-wrap - тоже что и pre,  но переносит строку если текст вылазит</li><li>pre-line - То же самое, что pre, но переводит строку, если текст вылезает из контейнера и не сохраняет пробелы.</li></ul> <br>outline - рамка, но в отличие от border, она не учвавствует в блочной модели сss <br><br> Box-sizing: задает правила расчетов размера элемента <ul><li>content-box - стандартный, width/height обозначают то, что находится внутри padding, бордеры не считаются</li><li>border-box - Значения width/height задают высоту/ширину всего элемента (вместе с паддингами и рамками)</li></ul> Margin - отступы вокруг элемента <br> Вертикальные поглощают друг друга, горизонтальные нет <ul><li>Отрицательные margin-left/top сдвигают элемент влево-вверх. Остальные элементы это учитывают, в отличие от сдвига через position. </li><li>Отрицательные margin-right/bottom заставляют другие элементы думать, что блок меньше по размеру справа-внизу, чем он на самом деле.</li></ul> При вставке img в документ, бывает у img снизу появляется отступ - решение сделать display: block или vertical-align: top, но при этом в таблице<br><br> Overflow: hidden(полоса прокрутки появляется когда элемент не влазит), scroll (полоса всегда), visible(стандартное, содержимое вылахит за границы), hidden (прячется если не влазит в элемент) <br><br> Height в %  работает, если у родителя устанволена высота. Также если у родителя есть min-height, то обязательно  height: 1px хотя бы <br><br>СSS селекторы <ul><li>* - любые элементы</li><li>div - элемент по тегу</li><li>#id - элемент по id</li><li>.class - элемент по классу</li><li>[name="value"] - элем по атрибуту</li><li>:visited - по псевдоклассу</li><li>.c1.c2 - два класса у элемента</li><li>div p - элеимент p, который потомок div</li><li>div > p - непосредственный потомок</li><li>div ~ p - правые  соседи на том же уровне вложенности p</li><li>div + p - первый правый сосед на том же уровне вложенности </li><li>:first-child - первый потому родителя</li><li>:last-child - последний потомок</li><li>only-child - единственный потомок</li><li>:nth-child(2) - второй потомок родителя</li><li>:nth-child(2n) - четные потомки, (2n+1) нечетные</li><li>:first-of-type, :last-of-type, 
        :only-of-type, :nth-of-type, :nth-last-of-type  - учитывает соседей только с таким же тегом</li><li>[attr="val"] - аттрибут равен val</li><li>[attr] - атрибут установлен</li><li>[attr^="val"] - атрибут начинается с val</li><li>[attr|="val"] - атрибут равен или начинается с val</li><li>[attr*="val"] - атрибут содержит val в подстроке</li><li>[attr~="val"] - cодержит val как одно из значений через пробел</li><li>[attr$="val"] - атрибут заканчивается на val </li><li>:not(селектор) – все, кроме подходящих под селектор. <li>:focus – в фокусе.</li> <li>:hover – под мышью.</li> <li>:empty – без детей (даже без текстовых).</li> <li>:checked, :disabled, :enabled – состояния INPUT.</li> <li>:target – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.</li><li>li::before { content: " [[ ";}  - псевдокласс  before </li><li> ::after (:after) - тоже что и before</li></ul>
        `
    }
]