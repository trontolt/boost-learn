import tableImg from '../../assets/images/table-example.png';
import nodeInsertLikeText from '../../assets/images/node-insert-like-text.png';
import nodeInsertLikeHTML from '../../assets/images/node-insert-like-html.png';
import elementsSizing from '../../assets/images/elements-sizing.png';
import mouseEvents from '../../assets/images/mouse-events.png';

export const titlesBomDomWithDescription = [
    {
        title: "Window/Dom/Bom",
        shortDesc: "<strong>Window</strong> - это контекст выполнения и глобальный объект для этого контекста. JavaScript <strong>document</strong> содержит DOM, инициализированный при разборе. HTMLscreen описывает физическое отображение на весь экран. <br><br> <strong>DOM</strong> (document object model) - (страница в виде объекта с точкой входа document) <br><br> <strong>BOM</strong> (browser object model) - (браузер в виде объекта navigator, location, setTimeout, alert, prompt, confirm)",
        description: ""
    },
    {
        title: "Селекторы узлов DOM",
        shortDesc: `Все узлы делятся на тесктовые узлы и элементы. В основном взаимодейтсвие идет с элементами поэтому мы используем методы для элементов, а не для всех узлов.<br> Выбрав элемент в меню разработчика можно нажать esc и  в консоли обращаться к выбранному элементу через $0 <br><code><ul><li style="padding:0; margin: 0;">document.body.<strong>childNodes</strong>                          псевдомассив всех детей элемента первого уровня вложенности, for_of  в нем работает</li><li><strong>.children</strong>           тоже самое только возвращает именно элементы, без текстовых узлов и т.д. </li><li>elem.<strong>firstChild</strong>           первый ребенок элемента. (=== elem.childNodes[0] )</li><li><strong>.firstElementChild</strong>       первый ребенок элемента (только элемент)</li><li>elem.<strong>lastChild</strong>         последний ребенок элемента ( === elem.childNodes[elem.childNodes.length - 1] )</li><li><strong>.lastElementChild</strong>        последний ребенок элемента (только элемент)</li><li>elem.<strong>hasChildNodes()</strong>         проверяет есть ли дети у элемента </li><li>document.body.<strong>parentNode</strong>         возвращает родителя (любого) </li>
        <li><strong>.parentElement</strong>         возвращает родительский элемент </li><li>document.head.<strong>nextSibling </strong>            следующий или правый сосед</li><li><strong>.nextElementSibling </strong>     тоже самое только элемент </li><li>document.body.<strong>previousSibling</strong>        предыдущий или левый сосед </li><li><strong>.previousElementSibling </strong>      тоже самое только элемент </li>    <hr><li>document.<strong>getElementById</strong>('elem');  вовращает элемент по id</li><li>document.<strong>querySelectorAll</strong>('ul > li:last-child');  возвращает массив элементов </li><li>elem.<strong>querySelector</strong>(css)              возвращает первый элемент удовлетворяющий запрос </li><li>elem.<strong>matches</strong>(css)       вовзвращает true or false если элемент удовлетворяет css селектор</li><li>elem.<strong>closest</strong>(css)          возвращает ближайшего предка (вверх), который удовлетворяет сss селектору</li><li>elem.<strong>getElementsByTagName</strong>(tag)  возвращает коллекцию элементов по тегу.</li><li>elem.<strong>getElementsByClassName</strong>(className)      возвращает коллекцию элементов по классу </li> <li>document.<strong>getElementsByName</strong>(name)  возвращает коллекцию элементов с атрибутом name </li><li>elemA.<strong>contains</strong>(elemB)      возвращает true, если А содержит внутри себя В</li></ul>`,
        description:""
    },
    {
        title: "Table",
        shortDesc: `<ul><li>table.<strong>rows</strong>            коллекция строк &lt;tr> таблицы.</li><li>table.<strong>caption/tHead/tFoot</strong>  ссылки на &lt;caption>, &lt;thead>, &lt;tfoot></li><li>table.<strong>tBodies</strong>         коллекция элементов таблицы &lt;tbody></li><li>tbody.<strong>rows, thead.rows, tfoot.rows </strong>         коллекция строк &lt;tr> секции</li><li>tr.<strong>cells</strong>              коллекция &lt;td> и &lt;th> ячеек, внутри строки &lt;tr>.</li><li>tr.<strong>sectionRowIndex</strong>       номер строки &lt;tr> в текущей секции &lt;thead>/&lt;tbody>/&lt;tfoot>.</li><li>tr.<strong>rowIndex</strong>          номер строки &lt;tr> в таблице (включая все строки таблицы).</li><li>td.<strong>cellIndex</strong>             номер ячейки в строке &lt;tr>.</li></ul><br><img alt='table-example' style="width: 15rem;" src='${tableImg}'/>`,
        description: ""
    },
    {
        title: "Содержимое узлов",
        shortDesc: `<ul><li>alert(elem.<strong>nodeType</strong>)         возвращает число (1 - если узел-элемент, 3- если текстовый узел, 9 -объект документа и.т.д.)</li><li>alert(document.body.<strong>nodeName</strong> );      // BODY  выводит название тега в верхнем регистре если не xhtml</li><li>alert( document.body.<strong>tagName</strong> );       // BODY для узлов не элементов описывает что это за узел</li><li>document.body.<strong>innerHTML</strong>        возвращает содержимое элемента в виде строки. Через = записывает новое содержимое</li><li>alert(elem.<strong>outerHTML</strong>)        возвращает содержимое элемента + сам элемент в виде строки. Через = вставляет на его место новый элемент </li><li>div.firstChild.<strong>data / nodeValue</strong>      возвращает содержимое текстового элемента</li><li>news.<strong>textContent</strong>        возвращает только текст, вычитая все вложенные тэги внутри элемента</li><li>elem.<strong>hidden</strong> = true;        скрывает элемент (как display:none)</li></ul> <hr> 
        Когда движок парсит html, он создает для каждого элемента объект, где свойства этого объекта все стандартные атрибуты элемента. У каждого элемента могут быть записаны нестандартные атрибуты, но они не записываются в свойства объекта при парсинге. Для этого есть такие методы в js <code><span class='code-example'><body id="test" something="non-standard"></span></code>. <ul><li>elem.<strong>hasAttribute</strong>(name)      проверяет наличие атрибута.</li><li>elem.<strong>getAttribute</strong>(name)         получает значение атрибута.</li> elem.<strong>setAttribute</strong>(name, value)    устанавливает значение атрибута.</li><li>elem.<strong>removeAttribute</strong>(name)    удаляет атрибут.</li><li>elem.<strong>attributes</strong>                           возвращает коллекцию атрибутов name:value </li><li><code><span class='code-example'><body <strong>data-about</strong>="Elephants"><br>&lt;script><br>alert(document.body.<strong>dataset.about</strong>);   // Elephants  // Доступ к атрибуту тега, который записан через data-...<br>&lt;/script>`
    },
    {
        title: "Изменение документа",
        shortDesc: `<div style="float:left"><code><span class='code-example'>&lt;script><br>let div = document.<b>createElement</b>('div'); <br> div.<b>className</b> = "alert";<br>div.<b>innerHTML</b> = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";<br>document.body.<b>append</b>(div);           добавляет узлы или строки в конец node <br> &lt;/script> <br><br> node.<b>prepend</b>(...nodes or strings)          вставляет узлы или строки в начало node, <br>node.<b>before</b>(...nodes or strings)           вставляет узлы или строки до node, <br> node.<b>after</b>(...nodes or strings)                    вставляет узлы или строки после node, <br>node.<b>replaceWith</b>(...nodes or strings)         заменяет node заданными узлами или строками. </span></code></div><div style="float:right;"><img style="width: 15rem;" src=${nodeInsertLikeText} /></div><hr style="clear:both"> <code><span class='code-example'>node.<b>remove</b>()               удаляет node <br>let div2 = div.<b>cloneNode</b>(true)        клонирует элемент (true - глубоко, false - без дочерних) <br>let fragment = <b>new DocumentFragment</b>();     создает узел обертку, которая исчезает при вставке, например для вставки многих &lt;li /> (исп редко) <br> document.<b>write</b>('&lt;b>Вставить что-то&lt;/b>')  добавляет содержимое на веб страницу( старый метод)</span></code> <hr> <div style="float: left"><code><span class='code-example'>&lt;div id="div">&lt;/div><br>&lt;script><br> div.<b>insertAdjacentHTML</b>('beforebegin', '&lt;p>Привет&lt;/p>'); <br> div.<b>insertAdjacentHTML</b>('afterend', '&lt;p>Пока&lt;/p>'); <br>&lt;/script> <br><br>"<b>beforebegin</b>" – вставить html непосредственно перед elem, <br>"<b>afterbegin</b>" – вставить html в начало elem, <br>"<b>beforeend</b>" – вставить html в конец elem, <br> "<b>afterend</b>" – вставить html непосредственно после elem.</div> <div style="float: right"><img style="width: 15rem" src=${nodeInsertLikeHTML} /></div>`,
        description : ""
    },
    {
        title: "js/css класы, стили",
        shortDesc: "document.body.<b>className </b>            возвращает класс <br> document.body.<b>className =</b> 'red'             заменяет класс <br> document.body.<b>classList</b>               перебираемая коллекция классов<br> document.body.<b>classList.add</b>('article');        добавляет класс <br> document.body.<b>classList.remove</b>('article');      удаляет класс <br> elem.<b>classList.toggle</b>('class')        добавить класс, если его нет, иначе удалить <br> elem.<b>classList.contains</b>('class')        проверка наличия класса (true, false) <br> document.body.<b>style</b>.backgroundColor                объект стилей элемента <br> div.style.<b>cssText</b>=`                  устанавливает новый css (если нужно сразу много свойств)<br> color: red !important; <br>width: 100px;<br>`;<br> let <b>cSt</b> = <b>getComputedStyle</b>(document.body);<br> <b>cSt</b>.marginTop                          получаем марджин",
        description: ""
    },
    {
        title: "Получение размеров элемента",
        shortDesc: `<div style='float:left'>alert(example.<b>offsetParent</b>.id);        находится предок элемента, для вычисления координат при рендере<br> alert(example.<b>offsetLeft</b>);            содержат координаты x/y относительно верхнего <br> alert(example.<b>offsetTop</b>)                          левого угла offsetParent. <br><br>function <b>isHidden</b>(elem) {                   проверка видим ли элемент <br> return <b>!elem.offsetWidth && !elem.offsetHeight</b>;     полная внешняя ширина и высота элемента <br> } <br> <ul><li><b>clientLeft</b>                 ширина отступа внутренней левой части элемента от внешней </li><li><b>clientTop</b>                 ширина отступа внутренней левой части элемента от внешней</li><li><b>clientHeight</b>               высота внутренней части элемента без паддингов и скроллбара</li><li><b>clientWidth</b>                ширина внутренней части элемента без паддингов и скроллбара</li><li><b>scrollHeight</b>                тоже самое только со скрытой (прокурученной) областью</li><li><b>scrollWidth</b>                 element.style.height <b>=</b> '$&#123;element.scrollHeight}px'; распахиваем элемент</li><li><b>scrollLeft</b>                ширина невидимой прокрученной области слева</li><li><b>scrollTop</b>                  высота невидимой прокрученной области сверху<br> (насколько прокручено, можно установить принудительно)</li></ul></div><div style='float: right;'><img style="width: 15rem" src=${elementsSizing}/></div> <hr style="clear:both">
        Для получения этих же данных об <b><u>окне браузера</u></b> нам стоит обращаться к <b>document.documentElement</b>.clientWidth (document.documentElement, соответствует тегу &lt;html>) <br>Для получения полной высоты окна изза ошибок разных браузеров стоит это делать так: <br><code><span class='code-example'> let scrollHeight = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight,   document.body.offsetHeight, document.documentElement.offsetHeight,   document.body.clientHeight, document.documentElement.clientHeight ); </span></code><br><br> window.<b>pageYOffset</b>           текущая прокурутка окна сверху для старых Safari (document.body.scrollTop/Left) <br>window.<b>pageXOffset</b>            текущая прокурутка окна слев <br>window.<b>scrollBy</b>(x,y)             прокручивает страницу относительно текущих координат на (влево, вниз) <br><b>scrollTo</b>(pageX,pageY)             прокручивает страницу на абсолютные координаты (влево, вниз) <br> elem.<b>scrollIntoView</b>(top)          прокрутить совместив верх элемента с верхом окна (если top=false то с низом окна) <br> document.body.style.<b>overflow = 'hidden'</b>          запретить прокрутку окна <br> document.body.style.<b>overflow = ''</b>   разрешить прокрутку окна <br>elem.<b>getBoundingClientRect()</b>       возвращает объект в котором  (x,y,width,height,top,bottom,left,right)  элемента относительно окна <br> document.<b>elementFromPoint</b>(X,Y);     возвращает самый глубоко вложенный элемент по заданным координатам находящийся в окне (не в окне - null)`,
        description: ""
    },
    {
        title: "Браузерные события",
        shortDesc: `<b>Браузерные события</b>    (1 стадия - погружение, 2 стадия достижения цели, 3- всплытие ) <code><span class='code-example'><ul><li>&lt;input value='жми' <b>onclick='alert(this.innerHTML)'</b> type='button' id='elem'>       ||     <b>onclick='sayThanks()'</b> </li><li> <b>elem.onclick</b> = function() { alert('Спасибо');};       ||     <b>button.onclick</b> = sayThanks </li><li> <b>elem.addEventListener</b>( 'click' , () => alert('Спасибо!')); <br>elem.<b>removeEventListener</b>( 'click', () => alert('Спасибо!')); </li></ul> </span></code><hr><div style='float: left'><ul><li><b>click / dblclick</b> - клик левой кнопкой мыши (тап на сенсоре) // двойной клик </li><li><b>contextmenu</b> - клик правой кнопкой мыши </li><li><b>mouseover/mouseout</b> - мышь наводится / покидает элемент (Переходы внутри элемента, на его потомки и с них, считаются. Всплывает)</li><li><b>mouseenter, mouseleave</b> - мышь наводится / покидает элемент (переходы на потомков внутри элемента не учитываются. Не всплывает)</li><li><b>mousedown</b> - мышь нажали</li><li><b>mouseup</b> - мышь отжали</li><li><b>mousemove</b> - движение мыши</li><li><b>touchstart, touchend, touchmove</b> - устаревшие события тача (аналогично мыши) </li><li><b>scroll</b> - прокрутка экрана</li></ul><br>Для правильной работы сенсорных экранов, пера, и т.д. был разработан стандарт 'pointer events', <br> который сразу генерирует и события мыши. Браузер генерирует события по умолчанию, например на кастомный drag'n'drop <br> может активировать встроенный (при этом генерит событие pointercancel), а для сенсорных экранов много других встроенных событий. <br> Чтобы такого не случалось в css - #ball { touch-action: none } </div><div style='float:right'><img alt='mouse-events' style='width: 15rem;' src=${mouseEvents} /><br>setPointerCapture - повзоляет <br> привязать  событие к одному <br> target, например зажали мышу<br> и тянем ползунок, при этом <br> курсор может<br> слететь с ползунка</div> <hr style='clear:both'>
        <ul><li>document.addEventListener(<b>"DOMContentLoaded"</b>, ready); - html загружен, DOM построен, скрипты подгружены, но не загружены внешние ресурсы </li><li><b>window.onload</b> = function() { alert('Страница загружена');}   - все загружено <br> <b>script.onload / onerror</b> = function() {...} - срабатывает когда скрипт загружен</li><li><b>window.onerror</b> = function(message, url, line, col, errorObj) { alert(message);} -  ошибка загрузки скрипта </li><li>window.addEventListener(<b>"unload"</b>, function() {       - пользователь покидает страницу (отправляем статистику) <br> navigator.sendBeacon("/analytics", JSON.stringify(analyticsData)); }); </li><li> window.<b>onbeforeunload</b> = function() { };                                   -    пользователь собирается покинуть страницу, можно задать вопрос </li><li>document.<b>readyState</b> == 'loading' || interactive  || complete  - свойства (документ загружается/полностью прочитан/полностью загружен) </li><li> document.addEventListener(<b>'readystatechange'</b>, () => console.log(document.readyState)); - реагирует на изменения readyState </li></ul><hr> <ul><li><b>submit</b> - отправили форму</li><li> <b>focus</b> - элемент в фокусе (инпут...) </li><hr><li><b>keydown и keyup</b> – когда пользователь нажимает / отпускает клавишу.</li><li>DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.</li><hr><li><b>transitionend </b> – когда CSS-анимация завершена.</li></ul><hr><ul>
        <li><b>event.which</b> - указывает какая кнопка мыши или клавиша клавиатуры нажата (1-левая кнопка мыши, 3 - правая и т.д.)</li><li><b>clientX/clientY</b> - Координаты курсора относительно окна<br><b>pageX/pageY</b> - Координаты курсора относительно документа: </li>
        <li><b>event.altKey && event.shiftKey && event.metaKey && event.ctrlKey</b> - указывает на нажатие клавиш-модификаторов </li><li><b>event.code</b>: ""KeyA", "ArrowLeft" - указывает какая клавиша нажата в формате KeyZ (всегда одинакова не зависит от регистра)</li><li><b>event.key</b>: "A", "a" - указывает какая клавиша нажата в формате z (такая же как нажата в регистре)</li><li><b>event.keyCode</b> - код нажатой клавиши в формате 16...</li> </ul> <hr>
        <b>Всплытие</b> - срабатывание обработчиков от элемента вверх к родителям и дальше по цепочек предков. <ol><li>this (=event.<b>currentTarget</b>)  - элемент до которого дошло всплытие и на нем сработал обработчик </li><li>event.<b>target</b> – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.</li></ol><ul><li>event.<b>stopPropagation()</b> - останавливает всплытие события от элемента</li><li>event.<b>preventDefault()</b> - удаляет стандартное поведение браузера с элемента (можно в обработчике просто вернуть false, будет тоже самое)</li> <li>event.<b>stopImmediatePropagation()</b> - останавливает всплытие и срабатывание события на данном элементе</li></ul> для перехвата события на <b>стадии погружения</b> elem.addEventListener("click", e => alert('Погружение: $&#123;elem.tagName}'), <b>true</b>); <br><b>Делегирование</b> - это способ навесить обработчик на много элементов путем навешивания на их общего родителя, и обработки события в нем при всплытии через event.target.`,
        description: ""
    },
    {
        title: "Пользовательские события",
        shortDesc: `Генерация пользовательских событий <br>

        <code><span class='code-example'>let event = <b>new Event(type[, options])</b>;</span></code>   // <b>type</b> - (click, my-event...), <b>options</b> = { bubbles: true - всплывает, cancelable: true - может быть отменено действ по умолчанию, composed: true - разрешить всплытие за пределы shadowDOM }) <br><br>
        <code><span class='code-example'> let event = <b>new Event("click")</b>; <br> <b>elem.dispatchEvent</b>(event);<br><br> event.<b>isTrusted</b> </span></code> - false  для событий которые порождены кодом, true - для событий порожденных действиями пользователя <hr>
        <code><span class='code-example'>&lt;script></span></code> для генерации кастомных событий лучше использовать данный ивент, т.к. в него можно передать details (пользовательские данные) <br>
        <code><span class='code-example'>elem.addEventListener("hello", function(event) {alert(event.detail.name);}); </span></code> - UIEvent, FocusEvent, MouseEvent, WheelEvent, KeyboardEvent <br>
        <code><span class='code-example'>elem.dispatchEvent(new CustomEvent("hello", {   bubbles: true,  detail: { name: "Вася" }})); <br> &lt;/script></span></code>`,
        description: ""
    },
    {
        title: "Форма. focus/blur",
        shortDesc: `Формы <br>
        <code><span class='code-example'>&lt;<b>form</b> name="my"><br> &lt;input name="one" value="1"> <br> &lt;input name="two" value="2"> <br>&lt;/form> </span></code> <br> <b>document.forms.my || document.forms[0]</b> - выбор формы <br> <b>form.elements.one  || form.one</b> - получаем инпут из формы <br> <b>element.form</b> - возвращает форму элемента по обратной ссылке <hr>
        Select<br>
        <code><span class='code-example'>&lt;<b>select</b> id="select"><br> &lt;option value="apple">Яблоко&lt;/option> <br> &lt;option value="pear">Груша</option> &lt;/select></span></code><br> <b>select.options[2].selected = true</b>;  - способ выбрать №1 <br> <b>select.selectedIndex = 2</b>   - способ выбрать No2 <br> <b>select.value = 'banana'</b> - способ выбрать No3 <br><br>option = <b>new Option</b>(text, value, defaultSelected, selected); - создали новый опшн <br> genres.append(option); - вставили новый опшн <hr>
        
        <code><span class='code-example'>input.<b>onblur</b> = function() {         - вызывается когда элемент теряет фокус <br>if (!input.value.includes('@')) { // не email <br> input.classList.add('invalid');     } }; <br><br> input.<b>onfocus</b> = function() {   - вызывается когда элемент получает фокус
         if (this.classList.contains('invalid')) {// удаляем индикатор ошибки, т.к.         this.classList.remove('invalid');     } }; </span></code><br><br> elem.focus() и elem.blur()   - устанавливают/снимают фокус. не всплывают (их можно отловить только на стадии погружения) <br> <b>focusin и focusout</b> – такие же, как и focus/blur, но они <u>всплывают</u>. <hr> <code><span class='code-example'>&lt;li tabindex="1">Один&lt;/li> </span></code>    - включает фокусировку на любом элементе <ul><li>tabindex= 0 - включает элемент в фокусируемые но не именяет порядок</li><li>tabindex=1....3,4,5 - включает фокусировку по порядку, затем идут 0 и стандартные фокусы</li><li>tabindex=-1 - позволяет фокусироваться только програмно</li></ul><b>change</b>       - Значение инпута было изменено и потеряло focus <br>
        <b>input</b>       - Срабатывает после каждого изменении значения инпута <br><br><b>cut/copy/paste</b>      - Действия по вырезанию/копированию вставке. <br>Действие можно предотвратить. Свойство <b>event.clipboardData</b> предоставляет доступ на чтение/запись в буфер обмена... <hr> <code><span class='code-example'>&lt;form onsubmit="alert('submit!');return false"> </span></code>  - отправляет форму (по нажатию enter, нажатию на &lt;input type="submit"> или &lt;input type="image">) <br> form.<b>submit()</b> - тоже отправляет форму (событие submit не генерируется)`,
        description: "",
    },
    {
        title: "Mutation Observer",
        shortDesc: `MutationObserver – это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений. <br><b>observer.observe(node, config);</b><br><br>
        
        let config = { <br><b>childList</b>: - изменения в непосредственных детях node, <br><b>subtree</b>: - во всех потомках node, <br><b>attributes</b>: - в атрибутах node, <br>
        <b>attributeFilter</b>: - массив имён атрибутов, чтобы наблюдать только за выбранными, <br><b>characterData</b>: - наблюдать ли за node.data (текстовое содержимое), <br>
        <b>characterDataOldValue</b>: – если true, будет передавать и старое и новое значение node.data в колбэк, иначе только новое (также требуется опция characterData),<br>
        <b>attributeOldValue</b>: – если true, будет передавать и старое и новое старое значение атрибута в колбэк, иначе только новое (также требуется опция attributes). <br>}
        <ol><li>let observer = <b>new MutationObserver</b>(mutationRecords => { console.log(mutationRecords); });</li><li>observer.<b>observe</b>(elemId, { childList: true, subtree: true, characterDataOldValue: true  });</li></ol>
        
        observer.<b>disconnect</b>() - останавливает наблюдение<br>mutationRecords = observer.<b>takeRecords</b>() - получает список необработанных записей изменений для которых еще не выполнился коллбэк`,
        description: ""
    },
    {
        title: "Выделение (range/selection)",
        shortDesc: `Выделение - <b>Range</b> (общий объект для управления диапазонами выделения) <b>Selection</b> (позволяет визуально выделять и захватывать выделенное) <br> <code><span class='code-example'>&lt;p id="p">Example: &lt;i>italic&lt;/i> and &lt;b>bold&lt;/b>&lt;/p> <br><br> let range = new Range(); <br> range.<b>setStart</b>(p, 0); //берем тэг p и берем его 0-ой дочерний элемент <br>range.<b>setEnd</b>(p.querySelector('b').firstChild, 3) // заканчивается на 3 позиции первого дочернего узла тега <br> alert(range) // Example: italic <br><br>document.<b>getSelection().removeAllRanges()</b>; <br>document.<b>getSelection().addRange(range)</b>; <br><br></span></code>
        Выделение в документе представлено объектом Selection, который может быть получен как <b>window.getSelection() или document.getSelection()</b>.
        `,
        description: "<b>События</b> выделения <br>elem.<b>onselectstart</b> – когда с elem начинается выделение, например пользовать начинает двигать мышкой с зажатой кнопкой.<br> preventDefault() отменяет начало выделения.<br>document.<b>onselectionchange</b> – когда выделение изменено.(Заметьте: этот обработчик можно поставить только на document.) <hr> <b>INPUT и TEXTAREA</b> имеют свои методы, свойства и события выделения, например: <ul><li>input.<b>selectionStart</b> – позиция начала выделения (это свойство можно изменять), </li><li>input.<b>selectionEnd</b> – позиция конца выделения (это свойство можно изменять),</li><li>input.<b>selectionDirection</b> - направление выделения, одно из: «forward» (вперёд), «backward» (назад) или «none» (без направления, если, к примеру, выделено с помощью двойного клика мыши)</li><li>input.<b>onselect</b> – <b>Событие</b> срабатывает, когда начинается выделение.</li><li>input.<b>select()</b> –<b>Метод</b>выделяет всё содержимое input (может быть textarea вместо input)</li><li>и другие...</li></ul><hr>css {user-select: none} делает невыделяемым"
    },
    {
        title: "Event Loop",
        shortDesc: `Event Loop - иструмент движка JS, который проверяет <b>Call Stack (стек вызовов)</b>, и если тот пустой - идет в <b>Task Queue (очередь задач)</b> и переносит оттуда первую задачу в Call Stack, при этом пропуская вперед очередь перерендера. Задача, попавшая в Сall Stack, выполняется моментально <hr>
        <div class='event-loop'>
            <div class='web-api'><h4>WEB API</h4><br>(onClick, onScroll, setTimeout, Ajax etc.)<div class='web-pipe-bottom'></div></div>
            <div class='task-queue'><h4>TASK QUEUE</h4><br>очередь задач<div class='task-pipe-bottom'></div></div>
            <div class='render-queue'><h4>RENDER QUEUE</h4><br>(браузерная очередь рендера, примерно раз в 16мс)<div class='render-pipe-bottom'></div></div>
            <div class='call-stack'><h4>CALL STACK</h4><br>(стек вызовов)<div class='event-loop-circle'>Event Loop</div></div>
        </div>`
    }
]