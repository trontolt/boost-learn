export const titlesReactWithDescrition =[
    {
        title: "Подключение",
        shortDesc: "// <b>Примечание: при деплое на продакшен замените «development.js» на «production.min.js». </b> <br><br> <code><span class='code-example'>&lt;script src='https://unpkg.com/react@17/umd/react.development.js' crossorigin>&lt;/script><br>&lt;script src='https://unpkg.com/react-dom@17/umd/react-dom.development.js' crossorigin>&lt;/script><br><br>// <b> Загрузим наш React-компонент. </b><br>&lt;script src='like_button.js'>&lt;/script> <hr> <b>В HTML создаем контейнер для реакта</b> <br>&lt;div id='like_button_container'>&lt;/div> <br><br><b>Подключаем react к html</b> <br>const domContainer = document.querySelector('#like_button_container'); <br>ReactDOM.render(e(LikeButton), domContainer);</span></code>",
        description: "Чтобы добавить jsx <br> <code><span class='code-example'>&lt;script src='https://unpkg.com/babel-standalone@6/babel.min.js'>&lt;/script> </span></code> <br>Теперь синтаксис JSX доступен внутри каждого &lt;script>-тега, у которого есть атрибут type='text/babel'<br><br> Создать проект в с реактом и jsx мгновенно (епсли есть create-react-app) - <code><span class='code-example'>npx create-react-app my-app<br>cd my-app<br>npm start</span></code>"
    },
    {
        title: "Компоненты/пропсы",
        shortDesc: "Компоненты: <ul><li>Функциональные: <br><code><span class='code-example'>function Welcome(props) { <br> return <h1>Привет, {props.name}</h1>; <br>}</span></code< </li><li> Классовые: <code><span class='code-example'>class Welcome extends React.Component { <br> render() { <br> return <h1>Привет, {this.props.name}</h1>; <br> } <br> } </span></code></ul>",
        desctiption: ""
    },
    {
        title: "Жизненный цикл",
        shortDesc: "<ol><li>constructor - начальная инициализация компонента</li><li>static getDerivedStateFromProps(props, state) - вызывается перед рендерингом компонента</li><li>render - рендеринг компонента</li><li>componentDidMount() - сразу после рендеринга</li><li>componentWillUnmount() - перед удалением компонента из DOM</li></ol><br><br> Еслит в компоненте происходят обновления после первоначального рендеринга, то вызываются такие этапы жизненного цикла компонента: <ol><li>static getDerivedStateFromProps(props, state)</li><li>shouldComponentUpdate(nextProps, nextState) - вызывается каждый раз при обновлении props или state, В качестве параметра передаются новый объект props и state. По умолчанию возвращает true, если вернуть false то компонент больше не будеот обновляться</li><li>render() -  рендеринг компонента (если shouldComponentUpdate возвращает true)</li><li>getSnapshotBeforeUpdate(prevProps, prevState) - перед непосредственным обновлением компонента, позволяет получить информацию из DOM перед возможным обновлением. Можно вернуть значение, которое будет передано в componentDidUpdate</li><li>componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления компонента (если shouldComponentUpdate возвращает true). В качестве параметров передаются старые значения объектов props и state. Третий параметр - значение, которое возвращает метод getSnapshotBeforeUpdate</li></ol><br>Изменение состояния компонента: <code><span class='code-example'><br>this.setState({ <br>counter: this.state.counter + this.props.increment,<br> }); <br><br>this.setState((state, props) => ({   // функция гарантированно получает предыдущее состояние первым аргументом <br> counter: state.counter + props.increment<br> })); </span></code>",
        description: ""
    },
     {
         title: "Обработка событий",
         shortDesc: "<table><thead><tr><td>В html</td><td>В react</td></tr></thead><tbody><tr><<td><code><span class='code-example'>&lt;button onclick='activateLasers()'><br>Активировать лазеры <br>&lt;/button></span></code></td><td><code><span class='code-example'><code><span class='code-example'>&lt;button onClick={activateLasers}><br>Активировать лазеры <br>&lt;/button></span></code></td><td>Навешивание события</td></tr><tr><td><code><span class='code-example'>&lt;form onsubmit='console.log('Отправлена форма.'); return false'></span></code></td><td><code><span class='code-example'>function handleSubmit(e) { <br> e.preventDefault(); <br>console.log('Отправлена форма.');<br> }</span></code></td><td>Отмена события</td></tr></tbody></table> <br> Привязывание метода: <ul><li><code><span class='code-example'>handleClick() { <br> this.setState(prevState => ({ <br> isToggleOn: !prevState.isToggleOn <br>})); } <br><br><b>В конструкторе - this.handleClick = this.handleClick.bind(this);</b></span></code></li><li><code><span class='code-example'>handleClick = () => { <br> console.log('значение this:', this);  //<b> таким методом привязывается this, экспериментальный метод</b><br> }</span></code></li><li><code><span class='code-example'> &lt;button onClick={<b>() =></b> this.handleClick()}> //<b>Такой метод тоже гарантирует привязку, но если он передается пропом в дочерний компонент - будет много перерендеров</b></span></code></li></ul>",
         description: ""
     }, 
     {
         title: "Условный рендеринг", 
         shortDesc: "<code><span class='code-example'><ol><li>function Greeting(props) { <br> const isLoggedIn = props.isLoggedIn; <br> if (isLoggedIn) { <br> return &lt;UserGreeting />; <br>} <br> return &lt;GuestGreeting />; <br> } <br><br><b>&lt;Greeting isLoggedIn={false} /></b></li><li>class LoginControl extends React.Component { <br> ...<br><br>render() { <br> const isLoggedIn = this.state.isLoggedIn; <br> let button; <br> if (isLoggedIn) { <br>button = <LogoutButton onClick={this.handleLogoutClick} />; <br> } else { <br> button = <LoginButton onClick={this.handleLoginClick} />; <br> }}<br>return (<br> <b>&lt;div>{button}&lt;/div></b><br>)</li><li>function Mailbox(props) { <br> const unreadMessages = props.unreadMessages; <br>return (<br>&lt;div><br>&lt;h1>Здравствуйте!&lt;/h1><br><b>{unreadMessages.length > 0 &&</b> <br> &lt;h2> У вас {unreadMessages.length} непрочитанных сообщений. &lt;/h2> <br> <b>}</b> <br> &lt;/div> <br>);}</li><li>render() {<br> const isLoggedIn = this.state.isLoggedIn; <br> return (<br>&lt;div> <br> Пользователь <b>{isLoggedIn ? 'сейчас' : 'не'}</b> на сайте. <br> &lt;/div> <br> );}</li></ol></span></code>",
         description: ""
     },
     {
         title: "Формы",
         shortDesc: "В реакте &lt;input>, &lt;textarea> и &lt;select> при изменении сами должны менять свой state. Тоесть при изменении вызывают setState и меняют свой value, такие компоненты называются '<b>управляемые</b>' <br><code><span class='code-example'>class NameForm extends React.Component { <br> constructor(props) {super(props);<br>this.state = {value: ''};<br><br>this.handleChange = this.handleChange.bind(this);<br>this.handleSubmit = this.handleSubmit.bind(this);<br>}<br><br>handleChange(event) {<br>this.setState({value: event.target.value});<br>}<br><br>handleSubmit(event) {<br>alert('Отправленное имя: ' + this.state.value);<br>event.preventDefault();<br>}<br><br>render() {<br>return (<br>&lt;form onSubmit={this.handleSubmit}><br>&lt;label><br>Имя:<br><br>&lt;input type='text' <b>value={this.state.value} onChange={this.handleChange}</b> /><br> или &lt;textarea <b>value={this.state.value} onChange={this.handleChange}/> </b> <br> или &lt;select <b>value={this.state.value} onChange={this.handleChange}></b> <br>&nbsp;&lt;option value='grapefruit'>Грейпфрут</option>... <br><br>&lt;/label><br>&lt;input type='submit' value='Отправить' /><br>&lt;/form><br>);}}</span></code> <hr> Редко используются неуправляемые компоненты, тоесть те кторые хранят свои состояния в DOM <br> <code><span class='code-example'>class NameForm extends React.Component { constructor(props) {<br>super(props);<br>this.handleSubmit = this.handleSubmit.bind(this);<br>this.input = <b>React.createRef()</b>;<br>}<br><br>handleSubmit(event) {<br> alert('Отправленное имя: ' + <b>this.input.current.value</b>);<br>event.preventDefault();<br>}<br><br>render() {<br>return (<br>&lt;form onSubmit={this.handleSubmit}><br>&lt;label><br>Имя:<br>&lt;input type='text' <b>ref={this.input}</b> /><br>&lt;/label><br>&lt;input type='submit' value='Отправить' /><br></form><br>);<br>}}</span></code> <hr> &lt;input type='file'> всегда является не управляемым компонентом, тоесть работает через DOM, доступ  к файлу осуществляется через <b>${this.fileInput.current.files[0]</b>.name}",
         description: ""
    },
    {
        title: "Композиция компонентов",
        shortDesc: "Это разделение функциональности на мелкие компоненты и соединение их воедино с помощью общего компонента контейнера. Желательно перенести все состояния компонентов во внешний statefull компонент, а их сделать stateless, также использовать { props.children } для рендеринга вставленного компонента <br><br><code><span class='code-example'>function Dialog(props) { return (<br><FancyBorder color='blue'><br>&lt;h1 className='Dialog-title'><br>{props.title}<br>&lt;/h1><br>&lt;p className='Dialog-message'><br>{props.message}<br></p><br>{props.children}<br></FancyBorder><br>);} <hr>And use this component inside the parent component<br><br>  &lt;Dialog <br>&nbsp; title='Программа исследования Марса' <br>&nbsp;message='Как к вам обращаться?'> <br>&nbsp;&lt;input value={this.state.login} <br>&nbsp; onChange={this.handleChange} <br>/> <br> &nbsp;&nbsp;&lt;button onClick={this.handleSignUp}> <br>&nbsp;&nbsp;Запишите меня! <br>&nbsp;&nbsp;&lt;/button><br>&lt;/Dialog></span></code>"
    }
]