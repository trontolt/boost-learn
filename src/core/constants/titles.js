export const titlesWithDescription = [
    {
        title: "JS это",
        shortDesc: "JS - Мультипарадигменный язык программирования, который добавляет интерактивность и динамику вебсайтам и приложениям (EcmaScript)",
        description: "Может выполняться в браузере, на сервере и в любом устройстве где есть движок JS. <br> Возможности js сильно зависят от среды, в которой запущен, например в браузере может добавлять Html, вазимодействовать с пользователями, менять стили, отправлять запросы, но <strong>не может</strong> записывать/читать/ файлы на жестком диске, запускать программы и т.д. "
    },
    {
        title: "Движки JS",
        shortDesc: "Это программа для выполнения кода JS в браузере, на сервере или устройстве <p>(<strong>V8</strong> - chrome,opera; <strong>Spider Monkey</strong> - Firefox; <strong>Trident, Chakra</strong> - IE; <strong>Nitro, SquirrelFish</strong> - Safari</p>",
        description: "<ul><li>Сперва движок парсит (читает текст скрипта) </li><li>Затем он компилирует (преобразует) скрипт в машинный язык <li>Применяя оптимизации запускает и выполняет машинный код</li></li></ul>"
    },
    {
        title: "Ссылки",
        shortDesc: "<a target='_blank' href='http://caniuse.com'>http://caniuse.com</a> ",
        description: "<a target='_blank' href='http://caniuse.com'>http://caniuse.com</a> - таблицы с информацией по поддержке движками браузеров новых возможностей"
    },
    {
        title: "<script>",
        shortDesc: "Добавляет JS в HTML <p><code><span class='code-example'>&lt;script src='file.js'&gt;&lt;/script&gt;<br>&lt;script&gt;alert(1);&lt;/script&gt; <hr> <code><span class='code-example'>&lt;script defer src='https://js'&gt&lt;/script&gt</span></code> - загружать скрипт в фоновом режиме. Запустить скрипт когда загрузится. Не блокировать html. <strong>Но DOMContentLoaded будет только после загрузки скрипта. Сохраняется порядок скриптов с defer.</strong> <br> <code><span class='code-example'>&lt;script async src='https://js'&gt&lt;/script&gt</span></code> - загружать скрипт в фоновом режиме. Запустить скрипт когда загрузится. не блокировать html. <strong>DOMContentLoaded не зависит от скрипта. Не сохраняется порядок выполнения.</strong> </span></code>",
        description: "<ul><li>Лучше выделять JS в отдельный файл, т.к. они загружаются отдельно и хранятся в кэше, что позволит другим подключающим данный скрипт страницам брать его из кэша</li><li>СЮда остальное</li></ul>"
    }, 
    {
        title: "Комментарии",
        shortDesc: "// - однострочные <br> /* многострочные */ <br> в HTML - &lt;!-- любой текст --&gt;",
        description: ""
    }, 
    {
        title: "Переменные",
        shortDesc: "Именованное хранилище для данных <ul><li> var - объявляет глобальную переменную</li><li>let - объявляет блочную переменую</li> <li>const - объявляет неизменную константу (блочная)</li>",
        description: "В названии первый символ не должен быть цифрой и не содержать '-'. Нельзя использовать зарезервированные имена let, class, return, function и т.д."
    }, 
    {
        title: "Типы данных",
        shortDesc: "JS динамически типизированный, так как в переменную можно поместить любой из 8 типов данных (String, Number, Boolean, Object, Undefined, Null, BigInt, Symbol) <br> <ul><li>number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).</li><li>bigint для целых чисел произвольной длины > ±(253-1) </li><li>string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.</li><li>boolean для true/false.</li><li>null для неизвестных значений – отдельный тип, имеющий одно значение null.</li><li>undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined</li><li>object для более сложных структур данных.</li><li>symbol для уникальных идентификаторов.</li></ul>",
        description: "<hr>typeof x или typeof(x) - возвращает строковое значение типа данных, <br>например typeof 1 = 'number', <br>typeof null = 'object'(специальная ошибка языка). <hr> В JS 7 примитивных типов данных и объекты. Для того чтобы у примитивов были методы, типа string.toUpperCase() JS создает легковесный объект-обертку для каждого из них при обращении к методу."
    },
    {
        title: "Number",
        shortDesc: "Number - (3, 2.1, infinity, NaN) <br> *1<strong>e9</strong> = 1млрд (e9 - 9 нулей после 1);  1<strong>e-6</strong> = 0.000001 (e-6 нули слева) <br> * <strong>toString</strong>(base); alert( 123456..toString(36)) // 2n9c (строковое число) <br> * <strong>Math.floor</strong> (округление в меньшую сторону 3.1 -3) <br> * <strong>Math.ceil</strong> (в большую сторону 3.1 - 4) <br> * <strong>Math.round</strong> (до ближайшего целого 3.6 - 4) <br> * <strong>Math.trunc</strong> (удаляет дробную 3.3 - 3) <br> * <strong>toFixed(2)</strong> (округляет до 2 знаков после запятой 3.3424 - 3.34) <br> *<strong>isNaN</strong>('str') //true преобразует значение в число и проверяет является ли оно NaN: <br> * <strong>isFinite</strong>('123') //true проверяет является ли обычным числом <br> * <strong>Object.is</strong>(12,14) //false проверяет равны ли друг другу (в отличие от '==' Object.is(NaN, NaN) === true,  Object.is(0, -0) === false <br> * <strong>parseInt</strong>('12.3px')  // 12 приводит к целому числу <br> * <strong>parseFloat</strong>('12.3.4') // 12.3 возвращает число с одной точкой <br> * <strong>Math.random</strong>() // случайное число от 0 до 1 <br> * <strong>Math.max</strong>(a, b, c...) / Math.min(a, b, c...) вычисляет макс и мин <br> * <strong>Math.pow</strong> (2, n) // возвращает 2 возведенное в степень n",
        description: ""

    },
    {
        title: "String",
        shortDesc: "let str = 'hello' <ul><li> `$&#123;str} world` //hello world // Интерполяция или обратные кавычки// backticks </li><li> alert ('hello'.<strong>length</strong>) // 5 - длина строки</li><li> str[0]  // h // если символа нет вернет undefined</li><li> str.<strong>charAt</strong>(0) - h //если символа нет вернет пустую строку</li><li>alert( 'Interface'.<strong>toUpperCase()</strong>); //INTERFACE</li><li>alert( 'Interface'.<strong>toLowerCase()</strong>); // interface </li><li> alert( 'Interface'<strong>[0].toLowerCase()</strong>); // 'i'</li><li>str.<strong>indexOf</strong>('substr', start) // возвращает позицию совпадения или -1</li><li>str.<strong>lastIndexOf</strong>('substr', start) // совпадение с конца</li><li>if (str.<strong>indexOf</strong>('Widget') != -1) { alert('Совпадение есть');</li><li>alert( 'Widget with id'.<strong>includes</strong>('Widget') ); // true</li><li>alert( 'Widget'.<strong>startsWith</strong>('Wid') ); // true</li><li>alert( 'Widget'.<strong>endsWith</strong>('get') ); // true,</li><li>'hello'.<strong>slice</strong>(1,3) // el - с второго по третий не включительно</li><li>'stringify'.<strong>substring</strong>(2,6) - ring - возвращает часть строки с 2 по 6</li><li>'stringify'.<strong>substr</strong>(2,2) - ri - возвращает 2 символа начиная с 2</li><li>alert( 'a' <strong>></strong> 'Z' ); // true // Сравнение строк по Unicode</li><li>str.<strong>codePointAt</strong>(pos) - возвращает код символа на позиции pos</li><li>alert( String.<strong>fromCodePoint</strong>(90) ); // Z  - возвращает символ по коду</li><li>str.<strong>localeCompare</strong>(str2) - сравнивает строки с учетом правил языка</li><li>str.<strong>trim</strong>() — убирает пробелы в начале и конце строки.</li><li>str.<strong>repeat</strong>(n) - Повторяет строку n раз",
        description: ""
    }, 
     {
         title: "alert, prompt,confirm",
         shortDesc: "<ul><li><span class='code-example'>let age = prompt('Сколько тебе лет?', 100);</span> - задает вопрос и присваивает ответ в переменную</li><li><span class='code-example'>alert('Hello');</span> - показывает сообщение</li><li><span class='code-example'>let isBoss = confirm('Ты здесь главный?');</span> - задает вопрос и присваивает переменной true или false</li></ul>",
         description: "Данные методы являются модальными, тоесть останавливают выполнение скрипта и не позволяют взаимодействовать со страницей. Расположение и внешний вид окна зависит от браузера."
     },
     { 
         title: "Приведение типов", 
         shortDesc: "<ul><li>Строковое String(value) - происходит когда нужно чтото вывести</li><li>Численное Number(value), +'1' - При математических операциях</li><li>Логическое Boolean(value) - При логических операциях</li></ul>",
         description: "<hr><ul><li>При строковом преобразовании: null - 'null', undefined - 'undefined' </li><li>При численном преобразовании: Undefined - NaN, <br>null - 0, true/false - 1/0,'string' - пробелы по краям обрезаются, если осталась пустая строка то 0, если число то считывается, иначе NaN </li><li> При логическом преобразовании: 0, null, undefined, NaN - false. Все остальное true, даже строка '&emsp;' или '0' тоже true</li>"
     },
    {
        title: "Базовые операторы", 
        shortDesc: "5 * 2 - (5) и (2) операнды или аргументы, (*) - бинарный операнд, так как применяется к двум операндам. +'1' - (+) унарный т.к. к одному операнду",
        description: "<ul><li>1 + 1 (2) сложение</li><li>1 - 1 (0) вычитание</li><li> 2 * 2 (4) умножение</li><li>4 / 2 (2) деление</li><li>5 % 2 (1) взятие остатка от деление</li><li>2 ** 3 (8) возведение в степень</li><li>a = 2 + 1 (3) присвоение</li><li><span class='code-example'>++counter</span> префиксный инкремент (-- декремент) увеличивает и возвращает увеличенное </li><li><span class='code-example'>counter++</span> постфиксный инкремент (-- декремент) возвращает значение затем увеличивает </li></ul> <hr> Бинарный плюс, если один из операндов строка - приводит к строке (2 + 2 + '1' = 41)"
    },
     {
         title: "Операторы сравнения",
         shortDesc:"<ul><li>5 > 2 // true</li><li>'я' > 'А' // true; 'а' > 'А' // true, лексикографическое сравнение по Unicode</li><li>'2' > 1 //true, строка приводится к числу. &emsp;('01' == 1) // true (строка 01 привелась в 1)</li><li>(0 === false) //false, разные типы</li><li>(0 == false) //true, без сравнения типов</li><li>(null == undefined) //true, равны друг другу ине равны ничему другому</li><li>(nul === undefined) //false, разные типы</li><li>!!'non-empty string' // true, '!' привело строку в булеан и вернуло противоположное, а второй '!'вернул его противоположное</li></ul>",
         description:"|| (или) - останавливается и возвращает первое истинное значение, или последнее если такое значение не найдено <br> && (и) - останавливается и возвращает первое ложное значение, или последнее еслит все истинные <hr> Объединение с null <strong>??</strong> - тоже что и  ||, только еще и видит '0' и '&emsp;' как true"
     }, 
     {
         title: "if, else, '?'",
         shortDesc: "<code><span class='code-example'>if (year < 2015) { <br> alert( 'Это слишком рано...' ); <br> } else if (year > 2015) { <br> alert( 'Это поздновато' ); <br> } else { <br>alert( 'Верно!' ); <br> }</span></code> <hr> <code><span class='code-example'>let accessAllowed = age > 18 ? true : false;</span></code>",
         description: "Тернарный оператор возвращает результат приведения к логическому типу <br><code><span class='code-example'> let message = (age < 3) ? 'Здравствуй, малыш!' : <br>(age < 18) ? 'Привет!' : <br> (age < 100) ? 'Здравствуйте!' : <br> 'Какой необычный возраст!';</span></code>"
     },
      {
          title: "Циклы",
          shortDesc: "<code><span class='code-example'>let i = 0;<br><strong>while</strong> (i < 3) { // выводит 0, затем 1, затем 2<br>alert( i );<br>i++;<br>}</span></code><hr><code><span class='code-example'>let i = 0;<br><strong>do</strong> {<br>alert( i );<br>i++;<br>} <strong>while</strong> (i < 3);</span></code><hr><code><span class='code-example'><strong>for</strong> (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2<br>alert(i);<br>}</span></code>",
          description:"<ul><li>В цикле for, можно пропускать части, например <code><span class='code-example'>for (; i < 3; i++) { // нет необходимости в 'начале'; alert( i ); // 0, 1, 2 }</span></code></li><li>Цикл можно прервать полностью- <code><span class='code-example'>while (true) { <br> let value = +prompt('Введите число', '');<br>if (!value) <strong>break</strong>; // (*)<br>sum += value;}</span></code></li><li>Прервать итерацию цикла и перейти к следующей - <code><span class='code-example'>for (let i = 0; i < 10; i++) {<br>if (i % 2 == 0) <strong>continue</strong>;<br>alert(i); // 1, затем 3, 5, 7, 9}</span></code></li><li>Метка для цикла - <code><span class='code-example'><strong>outer:</strong> for (let i = 0; i < 3; i++) { <br> for (let j = 0; j < 3; j++) { <br>let input = prompt(`Значение на координатах ($&#123;i},$&#123;j})`, ''); <br>// если пустая строка или Отмена, то выйти из обоих циклов <br>if (!input) break <strong>outer</strong>;}}</span></code></li></ul>Метка работает только снизу вверх"
      },
      {
          title: "Switch",
          shortDesc: "<code><span class='code-example'>let a = 2 + 2; <br> switch (a) { <br> case 4: <br> alert('Правильно!'); <br> break; <br>case 3: // (*) группируем оба case <br>case 5: <br> alert('Неправильно!'); <br> alert('Может вам посетить урок математики?'); <br> break; <br>default: <br> alert('Результат выглядит странновато. Честно.');}</span></code>",
          description: ""
      },
      {
          title: "Function",
          shortDesc: "Функция это фрагмент кода, к которому можно обратится по имени из другого места в коде. <br> <ul><li>Function declaration <code><span class='code-example'>function имя(параметры, через, запятую) {  /* тело, код функции */}</span></code> <br> (создается на стадии инициализации, до выполнения кода, может быть вызвана в любой части кода) <br> (В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.)</li><li>Function expression <code><span class='code-example'>let sayHi <strong>=</strong> function() {alert( 'Привет' );};</span></code> <br> (создается в момент когда до нее дошло выполнение кода, может быть вызвана только дальше по ходу выполнения кода)</li><li> Стрелочная функция <code><span class='code-example'>let arrF = (n) <strong>=></strong> n + 3</span></code> <br> <ul><li> У стрелочной нет this, она берет его снаружи, где была вызвана </li><li>Ее нельзя вызывать с new (будет ошибка)</li><li>У нее нет ...arguments</li><li>У нее нет super</li></ul></li><li><code><span class='code-example'>let sum = new Function('a', 'b', 'return a + b');</span></code> <br> (Хорошо подходит для создания функций, полученных из сервера строкой <br> Через new lexicalEnvironment - всегда global, тоесть данная функция имеет доступ только к глобальным переменным)</li></ul>",
          description:"<ul><li>У функций могут быть <strong>Локальные</strong> переменные (объявленные внутри. Доступ к ним есть только внутри функции) и <strong>Внешние</strong> (объявленные не в функции, а снаружи. Доступ к ним имеется и за пределами функции)</li><li>У функций есть свойство <strong>name, length</strong> (указывает количество принимаемых аргументов)</li><li>Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные – это не свойства функции и наоборот.</li><li><strong>NFE</strong> -  Named Function Expression. <br><code><span class='code-example'>let sayHi = function <strong>func</strong>s(who) { <br> if (who) { alert(`Hello, $&#123;who}`); <br> } else {  func('Guest'); //вызывает себя же } };</span></code></li><li>У функций могут быть принимаемые параметры и параметры по умолчанию <code><span class='code-example'>function func(who, <strong>age = 19</strong>) { return age }</span></code></li></ul>"
      },
    {
        title: "Тестирование", 
        shortDesc:"<strong>BDD</strong> behaviour driven development (тесты, документация, примеры использования) <br> <code><span class='code-example'>describe ('Заголовок', function () { <br>it ('Описание', function () { <br> assert.equal (pow(2,3), 8) <br> }}</span></code> <br> <strong>Mocha</strong> - функции тестирования (describe, it, функции запуска тестов) <br> <strong>Chai</strong> - функции проверки утверждений <br> <strong>Sinon</strong> - наблюдение за функциями, эмулирование встроенных функций",
        description :"describe ('Test', function () { <br> before ( () => alert('before tests')); <br> after ( ()=> alert('after tests')); <br> beforeEach ( ()=> alert ('before each test')) <br> afterEach ( ()=> alert ('after each test')); <br> it ('Возводит в степень n', function () { <br> assert.equal(pow(x,2), result); <br> });"
    }, 
    {
        title: "Полифилы, Babel",
        shortDesc: "Полифил - код, реализующий функциональность, которая не поддерживается в некоторых версиях веб-браузеров <br> Babel – это транспилер и полифил. Он переписывает современный JavaScript-код в предыдущий стандарт и реализовывает новые функции в старом стандарте.",
        description: ""
    }, 
    {
        title:"Object",
        shortDesc: "<ul><li>let user = new Object (конструктор объекта)</li><li>let user = {} (литерал объекта, литеральная нотация)</li></ul> <br><code><span class='code-example'>const user = { <br> name: 'Dima', <br>}; </span></code><br><ol><li><code><span class='code-example'>user.name = 'Petya'</span></code> // сработает, т.к. const не позволяет только полностью заменить объект.</li><li><code><span class='code-example'>let user = {} <br> user['likes birds']; <br> alert (user['like birds'])</span></code> // сработает изза [];</li><li><code><span class='code-example'> let user = { <br> name: 'Dima', <br> age: 29 <br> } <br> let key = prompt('что узнать', 'name'); <br> alert (user[key]);</span></code> // Dima</li><li><code><span class='code-example'> let fruit = prompt ('Какой фрукт', 'apple'); <br> let bag = { <br> [fruit] : 5 </span></code>//взяли имя из переменной <br> <code><span class='code-example'>} <br> alert (bag[fruit])</span></code> // 5; </li></ol>", 
        description: "Методы объекта: <ul><li> Object.keys(obj) – возвращает массив ключей. </li><li>Object.values(obj) – возвращает массив значений.</li><li>Object.entries(obj) – возвращает массив пар [ключ, значение].</li><li>Object.fromEntries(array) - превращает массив в объект </li><li>Object.getOwnPropertySymbols, - массив только символьных ключей.</li><li>Reflect.ownKeys(obj), возвращает все ключи.</li></ul> <br> Проверка наличия свойства в объекте <br> <code><span class='code-example'>let user = { name: 'Olga'} <br> alert ('name' <strong>in</strong> user) //true <br><br> <strong>for</strong> (key <strong>in</strong> user) { <br> alert(user[key]) <br> `} "
    }, 
    {
        title: "Клонирование/объединение объектов",
        shortDesc: "<code><span class='code-example'>let user  = { <br> name: 'Dima', <br> age: 29, <br> }; <br> let clone = {}; <br><ol><li>for (let key in user) { <br> clone[key] = user[key]  <br>} </li><li>Object.assign(clone, [user])</li><li>cloneDeep(obj) - Lodash</li><li>function <strong>cloneDeep</strong> (targetObj, srcObj) { <br> for(let key in srcObj) { <br> if(typeof (srcObj[key] != 'object') <br> targetObj[key] = srcObj[key]; <br> } else { <br> targetObj[key] = {}; <br> cloneDeep(targetObj[key], srcObj[key]); <br> }};</li><li>let clone = {...user}</li></ol>",
        description: ""
    }, 
    {
        title: "Сборка мусора",
        shortDesc: "<strong>Сборщик мусора</strong> - помечает корневые объекты, от них идет поссылкам и помечает другие объекты и т.д.. <br> Объекты, на которые нет внешних ссылок до корневых считаются недостижимыми и удаляются из памяти. <br><br> <strong>Оптимизации сборщика мусора</strong> <ol><li>Generational - делит объекты на новые и старые, старые проверяет реже</li><li>Incremental - поэтапно собирает мусор, делая много мелких задержек вместо одной большой</li><li>Idle - работает во время простоя процессора</li></ol>",
        description: ""
    },
    {
        title: "This",
        shortDesc: "This - это ключевое слово, указывающее на объект, который его вызвал. <br> <code><span class='code-example'>let user = { <br> name: 'Dima' <br> hi() { alert(this.name)} <br> by() { alert ('Пока')} <br> }; </span></code> <br><br> Важный момент! <br> <ul><li> При доступе к методу через точку и квадратные скобки в процессе присваивания без вызова метода потеряет this, потому как доступ будет осуществляться через ссылку <code><span class='code-example'>let hi = user.hi; <br> hi() </span></code> - выведет ошибку </li><li>Тоже самое с логическими операторами, при вычислении утрачивает this. <code><span class='code-example'> user.name == 'Dima' ? user.hi : user.by() </span></code> - Ошибка, т.к во время вычисления сразу не вызван метод, а получена ссылка на объект, Через ссылку утерян this</li> </ul>",
        description: "При use strict, если вызвать this  не у объекта будет ошибка. Без use strict , будет указывать на window"
    },
    {
        title: "Конструктор объектов",
        shortDesc: "Функция конструктор <br> <code><span class='code-example'>function User (name) { <br> this.name = name; <br> this.isAdmin = false; <br> } <br><br> let user = new User ('Dima'); </span></code> <br> Создает пустой this и возвращает заполненный в конце выполнения",
        description: "Если нужно проверить вызвана ли функция с помощью new, то нужно использовать <strong>new.target</strong><br><code><span class='code-example'>function User () { <br> alert(new.target) <br> } <br> User() //undefined <br> new User ()</span></code> // function User().... <hr> <ul><li> Можно вызвать без () если нет аргументов <code><span class='code-example'>let user = new User;</span></code></li><li> Любая функция может быть вызвана через new</li><li> Функция, вызванная через new возвращает объект this даже если нет return. Если указать явно return {любой: объект} то будет возвращен этот объект. Если просто написать return, то также вернется this</li>"
    },
    {
        title:"?.",
        shortDesc: "Опциональная цепочка. Позволяет избежать ошибки, когда обращаемся к вложенным объектам <br> <code><span class='code-example'>alert (user?.address?.street)</span></code> // <strong>undefined</strong> вместо ошибки, если бы были просто точки <br><br> Единственное условие, чтобы был создан первый объект в цепочке <strong>user</strong>.school.class",
        description: ""
    },
    {
        title: "Symbol",
        shortDesc: "Это примитив, использующийся для создания уникальных идентификаторов. <br><br> Если объект используется во многих частях кода, и возникла необходимость в него что-то добавить (напр. логи), то мы используем Symbol, так как он не виден в методах и циклах, что не сломает существующую логику <br><br> Символы при простом <strong>локальном</strong> создании типа <code><span class='code-example'>let name = Symbol('Kanye West')</span></code>: <ul><li>Всегда уникальны, даже с одинаковым именем  <code><span class='code-example'>Symbol('Kanye West') === Symbol('Kanye West') // false </span></code></li><li>Не виден методам и циклам типа object.keys, for in  и т.д.</li></ul> <code><span class='code-example'>alert (name.description) // Kanye West // Если нужен доступ к значению символа</span></code> <br> Если необходимо создать Symbol с уникальным неповторимым именем, то мы создаем его через <strong>глобальный</strong> реестр символов: <ul><li><code><span class='code-example'> let id = Symbol.<strong>for</strong>('id') </span></code> // создает символ в реестр, если такого нет </li> <li> <code><span class='code-example'>let idAgain  = Symbol.for('id') </span></code> //Теперь только читает и записывает его в переменную, так как уже создан <br> <code><span class='code-example'> alert (id === idAgain) </span></code> //true /это один и тот же символ т.к глобальный </li><li><code><span class='code-example'>alert(Symbol.<strong>keyFor</strong>('idAgain'))</span></code> // возвращает имя глобального символа, записанного в переменную idAgain </li></ul> Запись в объект: <code><span class='code-example'>let user = { name: 'Вася' }; <br>let id = Symbol('id'); <br>user[id] = 1; //Запись через [] <br> alert( user[id] )</span></code> // доступ через []",
        description: "Существуют системные символы, они отвечают за поведение объектов, например: <ul><li>Symbol.hasInstance</li><li>Symbol.toPrimitive</li><li>Symbol.iterator (вызов for of сперва вызовет эту функцию) - <code><span class='code-example'>let range = { from: 1,   to: 5 }; <br>range[Symbol.iterator] = function() { <br> return {     //возвращает объект с методом next() <br> current: this.from, <br> last: this.to, <br> next() { <br> if (this.current <= this.last) { //done: false, value - результат итерации <br> return { done: false, value: this.current++ }; <br> } else { <br> return { done: true };   //done: true прекращает цикл <br> }}}; };</span></code></li><li>[Symbol.isConcatSpreadable] - у объекта указывает что объект добавляет числовые значения в массив методом concat</li><li>[Symbol.asyncIterator] (for await..of вызывает этот метод один раз в начале) - <code><span class='code-example'>let range = { <br> from: 1, <br> to: 5, <br> <strong>[Symbol.asyncIterator]</strong> () { <br> return { <br> current: this.from, <br>   last: this.to, <br> async next() { </span></code> / /next() вызывается на каждой итерации цикла for await..of <br><code><span class='code-example'>await new Promise(resolve => setTimeout(resolve, 1000));  <br> if (this.current <= this.last) { <br> return { done: false, value: this.current++ }; <br> } else {return { done: true };}}};} <br> } <hr> (async () => { <br>  for await (let value of range) { // (4)alert(value); // 1,2,3,4,5}  } <br> )()"
    }, 
    {
        title: "Объект в примитив",
        shortDesc: "Существует три типа преобразований объекта в примитив: <ol><li>String - когда объект передается в alert и другие строковые операции</li><li>Number - для математических операций и сравнений</li><li>Default - для некоторых операций, в которых нет точной уверенности</li></ol> Алгоритм преобразования таков: <ul><li>Сперва вызывается современный метод obj[Symbol.toPrimitive](hint)</li><li>если его нет то обращается к устаревшим методам toString() и valueOf()</li></ul>",
        description: "<code><span class='code-example'>let user = { <br> name: 'John', <br> money: 1000, <br> [Symbol.toPrimitive](hint) { </span></code> // если есть данный метод то вызывает его <br><code><span class='code-example'>return hint == 'string' ? `{name: '$&#123this.name}'}` : this.money; }  }; <hr> let user = { name: 'John', <br> money: 1000, </span></code>&emsp;&emsp; если нет метода [Symbol.toPrimitive](hint) то обращается к старым методам <code><span class='code-example'><br> toString() { </span> // для хинта равного 'string' <br> <span class='code-example'> return `{name: '$&#123this.name}'}`; <br> }, <br> valueOf() {  </span> // для хинта равного 'number' или 'default' <br> <span class='code-example'>return this.money; <br> }};"
    },
    {
        title: "Array",
        shortDesc: `<strong>Массивы</strong> - упорядоченная коллекция данных. Как и объекты по ссылке. <br> Хранятся в неприрывной области памяти, поэтому быстро работают. <br> <code><span class='code-example'><ul><li>let arr = new Array(3) - Создать пустой массив длиной 3 элемента;</li><li> let arr = new Array('a', 'b') - Создать массив ['a','b'];</li><li>let arr = [];</li></ul> let fruits = ['Яблоко', 'Апельсин', 'Слива']; <br> fruits[3] = 'Лимон';</span></code> // Записали Лимон четвертым в массив <br> <code><span class='code-example'>alert( fruits.length ); </span></code>// 4<hr> <ul><li>fruits.<strong>pop</strong>() // удаляет последний элемент массива и возвращает его</li><li>fruits.<strong>push</strong>('Груша'); // добавляет элемент в конец массива</li><li>fruits.<strong>shift</strong>() // удаляет первый элемент массива и возвращает его</li><li>fruits.<strong>unshift</strong>('Яблоко', Груша'); //добавляет элементы в начало массива</li></ul><hr>let arr = ['Я', 'изучаю', 'JavaScript', 'тут]; <ul><li>arr.<strong>splice</strong>(0, 3, 'Давай', 'танцевать'); // ['Давай', 'танцевать', 'тут'] //удалить 3 первых элемента и заменить их другими, возвращает массив удаленных элементов ([я, изучаю, JavaScript])</li><li>arr.<strong>splice</strong>(2, 0, 'сложный', 'язык'); // вставить элементы  без вырезания</li><li>arr.<strong>splice</strong>(1, 1) // начиная с позиции 1, удалить 1 элемент ;</li><li> arr.<strong>concat</strong>([2, 'hello']) // копирует массив arr и добавляет в него все элементы массивов из аргументов, или других типов данных. Не изменяя arr </li><li> let arr = ['t', 'e', 's', 't'];  alert( arr.<strong>slice</strong>(1, 3) ) // e, s // копирует с 1 до 3 // если slice без аргументов - скопирует весь массив </li><li>arr.<strong>indexOf</strong>(item, from) ищет item, начиная с индекса from, и возвращает индекс или -1 </li><li> arr.<strong>lastIndexOf</strong>(item, from) – то же самое, но ищет справа налево. </li>
        <li> arr.<strong>includes</strong>(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен. </li><li>let arr = [1, 2, 3, 4, 5].<strong>reverse</strong>(); // 5,4,3,2,1 </li><li>let names = 'Вася, Петя, Маша'.<strong>split</strong>(', '); //['Вася', 'Петя', 'Маша'] </li><li>let arr = ['Вася', 'Петя', 'Маша'].<strong>join</strong>(';');  // Вася;Петя;Маша </li><li>Array.<strong>isArray</strong>([]); // true // проверяет на массив </li><li>arr.<strong>some</strong>(fn)/arr.<strong>every</strong>(fn) // возвращают true или false если в массиве есть совпадение <br>(fn - функция, например: const fun = (element) => element % 2 === 0; &emsp; &emsp; console.log(array.some(even)); //true ) </li><li> Array.<strong>from</strong>({ 0: "Hello",1: "World",   length: 2 }); // проверяет объект, является ли он псевдомассивом или итерируемым и делает массив. (итерируемый объект, это тот у которого есть [Symbol.iterator], а псевдомассив это объект у которого есть индексы и свойство length, при этом они могут и не быть друг другом например неитерируемый псевдомассив)</li><li>arr.<strong>reverse</strong>() - изменяет порядок элементов массива на обратный</li></ul>`,
        description: ""
    },
    {
        title: "Перебор массива",
        shortDesc: `Перебор массива: <ol><li><strong>for</strong> (let i = 0; i < arr.length; i++) {  alert( arr[i] );  } </li><li> <strong>for</strong> (let fruit <strong>of</strong> fruits) { alert( fruit ); } </li><li> <strong>for in</strong> - не рекомендуется, тк это метод ообъектов, работает медленно, выводит лишнее </li><li>arr.<strong>forEach</strong>(function(item, index, array) { // ... делать что-то с каждым item }); </li><li> let result = arr.<strong>find</strong>(function(item, index, array) { item.id == 1 }); //возвращает найденный элемент или undefined </li><li> let result = arr.<strong>findIndex</strong>(function(item, index, array) { item.id == 1 }); //возвращает индекс или -1 </li><li>let results = arr.<strong>filter</strong>(function(item, index, array) { item.id < 3 }); возвращает массив найденных элементов или undefined</li>
        <li>let result = arr.<strong>map</strong>(function(item, index, array) { // возвращает массив результатов выполнения функции к каждому элементу }); </li><li> <code><span class='code-example'>function compareNumeric(a, b) { if (a > b) return 1; if (a == b) return 0; if (a < b) return -1; }  <br>let arr = [ 1, 2, 15 ];  <br>arr.<strong>sort</strong>(compareNumeric)</span></code> </li><li><code><span class='code-example'>let arr = [1, 2, 3, 4, 5]; <br>let result = arr.<strong>reduce</strong>((sum, current) => sum + current, 0); </span></code> // 15 // Результат предыдущего вызова передается в следующий и аккумулирует его arr.<strong>reduceRight</strong> - тоже самое только справа налево`,
        description: ""
    }, 
    {
        title: "Map",
        shortDesc: `Map - коллекция ключ-значение, с ключом любого типа <ol><li> <strong>new Map</strong>() – создаёт коллекцию.</li><li> map.<strong>set</strong>(key, value) – записывает по ключу key значение</li><li>map.<strong>get</strong>(key) – возвращает значение по ключу </li><li>map.<strong>has</strong>(key) – проверка ключа, если есть true; </li><li> map.<strong>delete</strong>(key) – удаляет элемент по ключу key.</li><li>map.<strong>clear</strong>() – очищает коллекцию от всех элементов.</li><li>map.<strong>size</strong> – возвращает текущее количество элементов</li></ol>.
        Перебор map: <ul><li> map.<strong>keys</strong>() – возвращает итерируемый объект по ключам, </li><li> map.<strong>values</strong>() – возвращает итерируемый объект по значениям, </li><li> map.<strong>entries</strong>() – возвращает итерируемый объект по парам вида [ключ, значение] - (по умолчанию в for..of.) </li><li> <strong>for</strong> (let entry <strong>of</strong> recipeMap) { // } </li><li> recipeMap.<strong>forEach</strong>((value, key, map) => { // } </li></ul> При вставке сохраняется порядок сохранения ключей <br> let map = <strong>new Map</strong>(Object.entries(obj)); - создает map из массива ключей со значениями <br> let obj = Object.<strong>fromEntries</strong>(map.entries()) - создали object из массива ключ-значение map'а`,
        description: ""
    }, 
    {
        title: "Set",
        shortDesc: `Set - вид коллекции как массив, только с уникальными значениями <ol><li> <strong>new Set</strong>(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set. </li><li> set.<strong>add</strong>(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set. </li><li> set.<strong>delete</strong>(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false. </li><li>set.<strong>has</strong>(value) – возвращает true, если значение присутствует в множестве, иначе false. </li><li> set.<strong>clear</strong>() – удаляет все имеющиеся значения. </li><li> set.<strong>size</strong> – возвращает количество элементов в множестве.</li></ol>
        Перебор <br> let set = new Set(["апельсин", "яблоко", "банан"]);
        <ul><li> <strong>for</strong> (let value <strong>of</strong> set) alert(value); </li><li> set.<strong>forEach</strong>((value, valueAgain, set) => {alert(value); });</li><li>set.<strong>values</strong>() – возвращает перебираемый объект для значений, </li><li> set.<strong>keys</strong>() – также как и values() возвращает перебираемый объект для значений, создан для совместимости с map </li><li> set.<strong>entries</strong>() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map</li></ul>`,
        description: ""
    },
    {
        title: "WeakMap, WeakSet",
        shortDesc: "WeakMap - Коллекция пар ключ-значение, где в качестве ключей только объекты. <br> WeakSet тоже в качестве значений только объекты. <hr> Хранит ссылки на объекты в 'слабом режиме', тоесть если на объект больше нет ссылок с других источников, то WeakMap позволит Сборщику Мусора его удалить. <br> Также используется для кэширования данных, что позволяет функции не выполнятся многократно, а брать результат из кэша. <br> WeakMap <ol><li>В качестве ключей только объекты </li><li>Есть только методы: get, set, delete, has </li><li> Используется как дополнительное хранилище, так как при удалении объекта, который используется в качестве ключа, удаляется и из weakMap сборщиком мусора. </li><li> Часто используется для кэширования объекта и быстрого удаления </li></ol>",
        description: "",
    }, 
    {
        title: "Деструктуризация",
        shortDesc: "Деструктуризация - синтаксис, который позволяет упрощенно присваивать элементы массивов и объектов переменным. <ol><code><span class='code-example'><li> let [name1 = 'Default', ,name3=prompt('name?'), ...rest] = ['Julius', 'Caesar', ,'Dima', 'Consul'];</li><li> for (let [key, value] of Object.entries(user)) { alert(`$&#123;key}:$&#123;value}`);</li><li>let {title = 'default', width, height:newName = 'Ya'} = { title: 'Menu',   width: 100,   height: 200 };</li><li>let options = { title: 'My menu',   items: ['Item1', 'Item2'] }; <br> function showMenu({title = 'Untitled', width = 200, height = 100, items = []}) { <br> alert( `&#123;title} $&#123;width} $&#123;height}` ); <br> showMenu(options)} // My menu 200 100 </li></span></code></ol>",
        decription: ""
    }, 
    {
        title: "Date",
        shortDesc: "<ol><li> <strong>new Date</strong> (); - создает объект Дата с текущим временем </li><li> <strong>new Date(2011, 0, 1, 0, 0, 0, 0)</strong>; - создает дату с указанным временем (месяц 0 - январь) </li><li><strong>getFullYear(), getMonth(), getDate(), getHours(), getMinutes(), getSeconds(), getMilliseconds()</strong> - возвращают соответсвующее время. (<strong>getUTCFullYear(), getUTCMonth(), getUTCDay()</strong>) соотвественно в ЮТС </li><li> <strong>getDay</strong>() - возвращает день недели (0-воскресенье) </li><li> <strong>getTime</strong>() - для заданной даты возвращает таймстамп в мс (Быстро работает, так как нет преобразования дат) </li><li> <strong>getTimezoneOffset</strong>() - разница в местном времени и ЮТС </li><li> <strong>setFullYear(year, [month], [date]), setMonth(month, [date]), setDate(date) ,setHours(hour, [min], [sec], [ms]), setMinutes(min, [sec], [ms]), setSeconds(sec, [ms]), setMilliseconds(ms), setTime(milliseconds)</strong>  (также есть эти же методы с ЮТС вариантом, кроме setTime() </li><li> <strong>Date.now()</strong> - текущее количество миллисекунд с 1.01.1970 - используется чаще всего для просчетов </li><li> <strong>Date.parse</strong>('2012-01-26T13:51:50.417-07:00'); // 1327611110417 (таймстамп)",
        description: ""
    },
    {
        title: "JSON",
        shortDesc: "JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов. <ul><li>JSON.<strong>stringify</strong>(obj) - преобразовывает объект в строку (называется JSON-форматированный или сериализованный) </li><ul><li>Обращается к методу toJSON объектов.</li><li> Поддерживает Объекты, Массивы, строки, числа, логические значения true/false, null.</li><li>Пропускает *Свойства-функции (методы). *Символьные свойства. *Свойства, содержащие undefined.</li><li>НЕ конвертирует циклические объекты, то-есть указывающие друг на друга</ul></li><li><code><span class='code-example'>функция реплейсер: <br>alert( JSON.stringify(myObject, function replacer(key, value) { <br> alert(`$&#123key}: $&#123value}`);<br> return (key == 'occupiedBy') ? undefined : value; })); </span></code> //Если ключ не occupiedBy то серилизуем ключ, иначе возвращаем undefined</li><li>JSON.<strong>parse</strong>(str, [reviver]) - декодирует JSON строку в объект <code><span class='code-example'><br>функция ревьюер:<br> let str = '{'title':'Conference','date':'2017-11-30T12:00:00.000Z'}'; <br>let meetup = JSON.parse(str, function(key, value) { <br> if (key == 'date') return new Date(value);</span></code> // Если ключ == 'date, при преобразовании из JSON создадим объект Date как значение <br><code><span class='code-example'>return value; });</span></code></li></ul>",
        description: ""
    },
    {
        title: "Рекурсия, стек",
        shortDesc: "Рекурсия и стек - прием программирования, в котором функция вызывает сама себя, передавая измененный параметр, до выполнения определенного условия. <ol><li> Контекст выполнения - структура данных, которая содержит информацию о месте в коде, локальных переменных функции, значение this и другую информацию о функции. </li><li> Глубина рекурсии - количество вложенных вызовов.</li></ol> <code><span class='code-example'> function pow(x, n) { <br> if (n == 1) { <br> return x;<br> } else { <br> return x * pow(x, n - 1);}} </span></code>",
        description: ""
    },
     {
         title: "Оператор расширен/Остаточные парам",
         shortDesc: `<ol>
                        <li>Остаточные параметры ...args 
                            <ul>    
                                <li>в конце списка аргументов функции</li>
                                <li> function showName(firstName, lastName, ...titles) { }</li>
                            </ul>
                        </li>
                        <li>старый метод arguments - псевдомассив, содержал все аргументы вместе с остаточными. хуже.</li>
                        <li>Оператор расширения ... в вызове функции или где-либо ещё - Наоборот раскрывает массив <br><code><span class='code-example'> let arr1 = [1, -2, 3, 4]; <br> let arr2 = [8, 3, -8, 1];<br> 
                                <ul>
                                    <li> alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25 </li>
                                    <li> let merged = [0, ...arr, 2, ...arr2]; // 0,3,5,1,2,8,9,15 </li>
                                    <li> let str = 'Привет';   alert( [...str] ); // П,р,и,в,е,т </li>
                                </ul>
                    </ol>`,
        description: ""
     },
     {
         title: "Замыкание",
         shortDesc: "Замыкание - это комбинация функции и лексического окружения, в котором эта функция была определена. Через ссылку environment функция получает доступ к переменным окружения где была создана. Создается каждый раз при создании функции. <br><br> У каждой функции, блока кода, скрипта есть связанный скрытый объект LexicalEnvironment, он состоит из двух частей: <ul><li> Environment Record - Объект в котором в свойствах - все локальные переменные и this </li><li> Ссылка на внешнее лексическое окружение - окружение снаружи текущих фигурных скобок </li></ul> Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом и мы на самом деле работаем с ним. <br> Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется. Также для каждого блока кода типа if {} и для каждой итерации циклов",
         description: ""
     },
     {
         title: "var",
         shortDesc: "var - переменная <ul><li>не имеет блочной области видимости</li><li> ограничивается только функцией или скриптом.</li><li> Объявляется (инициализируется) всегда вначале исполнения функции или скрипта движком, но значение ей присваивается по мере дохождения кода.</li></ul>",
         description: ""
     },
     {
         title: "Глобальный объект",
         shortDesc: "Глобальный объект - в браузере <strong>window</strong>, в Node.js - <strong>global</strong><br><strong>globalThis</strong> - везде. В нем хранятся встроенные объекты, свойства окружения (innerHeight...)",
         description: ""
     },
     {
         title: "setTimeout/setInterval",
         shortDesc: "<code><span class='code-example'> function sayHi(phrase, who) { alert( phrase + ', ' + who ); } <br> let timerId = <strong>setTimeout</strong>(sayHi, 1000, 'Привет', 'Джон')</span></code> - вызывает функцию однократно <br> <code><span class='code-example'>clearTimeout(timerId);</span></code> - очищает таймер <br> <code><span class='code-example'> let timerId = <strong>setInterval</strong>(() => alert('tick'), 2000);</span></code> - вызывает функцию с интервалом <br><br>Рекурсивный setTimeout <br><code><span class='code-example'> let timerId = setTimeout(function tick() { <br> alert('tick'); <br> timerId = setTimeout(tick, 2000); <br> }, 2000);</span></code> <br> setImmediate - в Node.js",
         description: ""
     },
     {
         title: "Декоратор",
         shortDesc: `<strong>Декоратор</strong> - функция обертка, которая расширяет функционал переданной в нее функции.<br>
         <code><span class='code-example'>function slow(x) { <br> // ресурсоемкие вычисления <br> return x; } <hr> function <strong>cachingDecorator</strong>(func) { <br> let cache = new Map(); <br> return function(x) { <br> if (cache.has(x)) {       // если кеш содержит такой x, <br> return cache.get(x);     // читаем из него результат <br> } <br> let result = func(x);   // иначе, вызываем функцию <br> cache.set(x, result);    // и кешируем (запоминаем) результат <br> return result  <br> }; } <br><br> slow = cachingDecorator(slow); <br> alert( slow(1) ); // slow(1) кешируем  <br> alert( "Again: " + slow(1) ); // возвращаем из кеша </span></code>`,
         description: ""
     },
     {
         title: "call/apply/bind",
         shortDesc: "func(1, 2, 3);<hr> func.<strong>call</strong>(obj, 1, 2, 3) - вызывает функцию с явно установленным this и аргументами <br> func.<strong>apply</strong>(context, args); - вызывает функцию с явно установленным this,  принимает псевдомассив аргументов. <br> let funcUser = func.<strong>bind</strong>(user) - фиксирует this, даже, если он изменится, то останется зафиксированный. <br> Также можно передать аргументы, они привяжутся и будут всегда передаваться первыми (let double = mul.<strong>bind(null, 2)</strong>;) <br> если нужно зафиксировать контекс для всех методов - <strong>_.bindAll(obj) lodash</strong><br> роеализация bindAll <br><code><strong> for (let key in user) { <br> if (typeof user[key] == 'function') { <br> user[key] = user[key].bind(user); <br> }} </span></code>",
         description: ""
     },
     {
         title: "Флаги свойств",
         shortDesc: "Флаги свойств, они же дескрипторы, являются опциями для управления свойством объекта <ul><li> writable - false (только для чтения) </li><li> enumerable - false (циклы игнорируют)</li><li>configurable - false (не удаляется и не изменяются предыдущие свойства)</li></ul> Object.<strong>getOwnPropertyDescriptor</strong>(obj, propertyName); - вся инфа о свойстве <br> Object.<strong>getOwnPropertyDescriptors</strong>(obj) <br> Object.<strong>defineProperty</strong>(user, 'name', {  writable: false }); - по умолчанию если свойство не содано, создается с all false <br> Object.<strong>defineProperties</strong><code><span class='code-example'> (user, { <br> name: { value: 'John', writable: false },   <br> surname: { value: 'Smith', writable: false <br> },// ... }); </span></code> <br> Object.<strong>preventExtensions</strong>(obj) - запрет на добавление новых свойств <br> Object.<strong>seal</strong>(obj) - configurable: false для всех свойст <br> Object.<strong>freeze</strong>(obj) - configurable: false, writable: false для всех свойств <br> Object.<strong>isExtensible</strong>(obj) - возвращает false если добавление свойств запрещено <br> Object.<strong>isSealed</strong>(obj) - возвращает true если configurable: false. <br> Object.<strong>isFrozen</strong>(obj) - возвращает true, если configurable: false, writable: false.",
         description: ""
     },
     {
         title: "Аксессоры",
         shortDesc: "Существует два типа свойств объекта <ol><li>Свойства-данные (data properties)</li><li>Аксессоры (геттеры/сеттеры) acessor props - это функции, для присвоения и получения значений, которые во внешнем коде выглядят как обычные свойства объекта</li></ol> <code><span class='code-example'>let user = { <br> name: 'John', <br> surname: 'Smith', <br> <strong>get</strong> fullName() {       - возвращает свойство <br> return `$&#123;this.name} $&#123;this.surname}` <br>;}, <br> <strong>set</strong> fullName(value) {  - устанавливает свойство <br> [this.name, this.surname] = value.split(' '); <br>} }; <hr> user.fullName = 'Alice Cooper';  // set fullName запустится с данным значением <br> alert(user.name); // Alice <br> alert(user.fullName); // Alice Cooper <hr> у них есть такие дескрипторы (get, set, enumerable, configurable)",
         description: ""
     },
     {
         title: "Прототипы",
         shortDesc: `Прототипное наследование <br>
         <code><span class='code-example'> let animal = { eats: true }; <br> let rabbit = {   jumps: true }; <br> rabbit.<strong>__proto__</strong> = animal; </span></code>  // геттер/сеттер для [[Prototype]] (устарел) <br>
         Object.<strong>create</strong>(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors. <br> Object.<strong>getPrototypeOf</strong>(obj) – возвращает свойство [[Prototype]] объекта obj. <br> Object.<strong>setPrototypeOf</strong>(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto. <hr> <code><span class='code-example'>let animal = { eats: true }; </span></code> <br> // создаём новый объект с прототипом animal <br>
         <code><span class='code-example'> let rabbit = Object.create(animal); <br> alert(rabbit.eats);  // true <br> alert(Object.getPrototypeOf(rabbit) === animal);</span></code>   // получаем прототип объекта rabbit  <br> <code><span class='code-example'> Object.setPrototypeOf(rabbit, {}); </span></code> // заменяем прототип объекта rabbit на {} <hr> <code><span class='code-example'> for(let prop in rabbit) { </span></code> цикл for in проходит по всем ключам, даже унаследованным в отличии от Object.keys() <br> <code><span class='code-example'>let isOwn = rabbit.hasOwnProperty(prop); </span></code>    //true если свойство не унаследовано <br> <code><span class='code-example'> if (isOwn) { <br> alert('Our: $&#123;prop}'); </span></code> // Our: jumps <br> <code><span class='code-example'} else { <br> alert('Inherited: $&#123;prop}'); </span></code> // Inherited: eats}} <hr>
         Продуктивное клонирование объекта <br> <code><span class='code-example'> let clone = Object.create(Object.getPrototypeOf(obj), <br> Object.getOwnPropertyDescriptors(obj)); </span></code> <hr> В функции-конструкторе указать на прототип  при создании можно так: <br> 
         <code><span class='code-example'> let animal = { eats: true }; <br> function Rabbit (name) { <br> this.name = name; <br> } <br> Rabbit.prototype = animal; <br> let rabbit = new Rabbit("White Rabbit");  </span></code> //  rabbit.__proto__ == animal <br> <code><span class='code-example'> alert( rabbit.eats ); </span></code> // true </span></code><hr> Все встроенные объекты следуют одному шаблону: <ul><li> Методы хранятся в прототипах (Array.prototype, Object.prototype, Date.prototype и т.д.).</li><li> Сами объекты хранят только данные (элементы массивов, свойства объектов, даты).</li><li>Примитивы также хранят свои методы в прототипах объектов-обёрток: Number.prototype, String.prototype, Boolean.prototype. Только у значений undefined и null нет объектов-обёрток.</li></ul> Если мы хотим использовать в качестве ключей объекта пользовательские значения (введенный пользователем), то лучше создавать объект таким образом <code><span class='code-example'> let chineseDictionary = Object.create(null); </span></code> что позволяет убрать прототип у объекта`,
         description: ""
     },
     {
         title: "Class",
         shortDesc: `Классы - расширяемый шаблон кода для создания объектов, устанавливает начальные свойства и методы. Разновидность функции-конструктора. При создании класса, создается функция конструктор в прототип которой записываются методы класса. Экземпляр созданный через new MyClass, имеет доступ к этим методам <br>
         <code><span class='code-example'><strong>class</strong> Animal { <br> name = "Животное"; <br> constructor(name) { <br>this.speed = 0; <br> this.name = name; <br> } <br> run(speed) { <br> this.speed = speed; <br> alert('$&#123;this.name} бежит со скоростью $&#123;this.speed}.'); <br> } <br> <strong>get</strong> something(...) {} // геттер <br> <strong>set</strong> something(...) {} // сеттер <br><strong>[Symbol.iterator]</strong>() {} // метод с вычисляемым именем (здесь - символом) <br> } <hr> let animal = new Animal(); <hr>
         class Rabbit <strong>extends</strong> Animal {  // кролик наследует методы от животного <br> constructor(name, earLength) { <br> <strong>super</strong>(name);  //если класс наследует у другого класса, то для создания this в конструкторе необходимо вызвать super (он указывает родителю создать пуст объект this) <br> this.earLength = earLength;  <br> } <br> hide() { <br> alert('$&#123;this.name} прячется!'); <br>}} </span></code><hr>
         *Мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent. <br> Внутренние детали: <br> *Методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super, он в его прототипе ищет родительские методы. <br>Поэтому копировать метод, использующий super, между разными объектами небезопасно. <hr> <code><span class='code-example'> class MyClass { <br> static property = ...;    Статические методы используются для функциональности, принадлежат классу «в целом», а не относятся к конкретному объекту класса. Грубо говоря это методы функции-конструктора, который не записываются в каждый объект, а остаются существовать только в функции. Технически это как присвоить функции свойство  <br> static method() {...} <br>} </span></code>`,
         description: ""
     }, 
     {
         title: "Приватные свойства",
         shortDesc: "Приватные и защищенные свойства. <br> Интерфейс разделяется на внутренний и внешний (в ООП инкапсуляция). <br>Во внутреннем методы и свойства доступны из других методов класса, но не с наружи. Во внешнем доступны снаружи. <br> <code><span class='code-example'> class CoffeeMachine { <br> <strong>#</strong>waterLimit = 200;  // #означает, что поле приватное. Нет доступа извне или из наследуемых классов. // На уровне языка <br><strong>#</strong>checkWater(value) {   // тоже самое приватное <br> if (value < 0) throw new Error('Отрицательный уровень воды'); <br> if (value > this.#waterLimit) throw new Error('Слишком много воды'); <br>} <hr> <strong>_</strong>waterAmount = 0; // это поле защищенное, оно наследуется но доступ к нему через геттеры и сеттеры <hr> <strong>set</strong> waterAmount(value) {     &emsp;&emsp;&emsp;&emsp;    setWaterAmount(value) {.  //можно использовать функцию <br> if (value < 0) throw new Error('Отрицательное количество воды'); <br> this._waterAmount = value; <br> } <br> get waterAmount() {      &emsp;&emsp;&emsp;&emsp;&emsp;         getWaterAmount() {   //можно использовать функцию //лучше <br> return this._waterAmount; <br> } <hr> constructor(power) { <br> this._power = power; <br>} <br>} </span></code>",
         description: ""
     },
     {
         title: "instanceOf",
         shortDesc: "<code><span class='code-example'> class Rabbit {}     &emsp;&emsp;&emsp;&emsp;   // или функция конструктор function Rabbit() {} <hr> let rabbit = new Rabbit(); <br> alert( rabbit instanceof Rabbit ); </span></code> // возвращает true, если объект принадлежит или наследует от класса  или конструктора <hr> Данный метод можно настроить как угодно <code><span class='code-example'> class Animal { <br> static <strong>[Symbol.hasInstance](obj)</strong> { <br>if (obj.canEat) return true; <br> }} <br><br> let obj = { canEat: true }; <br> alert(obj instanceof Animal);</span></code> // true: вызван Animal[Symbol.hasInstance](obj)<hr> Есть метод objA.isPrototypeOf(objB), который возвращает true, если объект objA есть где-то в прототипной цепочке объекта objB",
         description: ""
     },
     {
         title: "try/catch",
         shortDesc: `<code><span class='code-example'>let json = '{ "age": 30 }'; // данные неполны <br> <strong>try</strong> { <br> let user = JSON.parse(json); <br> if (!user.name) { <strong>throw new SyntaxError</strong>("Нет имени"); // (Error, SyntaxError, ReferenceError, TypeError etc) <br>}<br> alert( user.name ); <br> } <strong>catch</strong>(e) { <br> if (e.name == "SyntaxError") { <br> alert( "JSON Error: " + e.message ); <br> } else { <br> <strong>throw</strong> e; // проброс (*)} <br> } finally {    // необязательный блок <br> alert('файнэли выполнится полюбому') <br> }`,
         description: ""
     },
     {
         title: "Callback",
         shortDesc: "Функции коллбэки - это функции, которые передаются в виде аргумента другой функции, для того чтобы быть вызванными после выполнения определенных действий <br> <code><span class='code-example'> function loadScript(src, <strong>callback</strong>) { <br> let script = document.createElement('script'); <br> script.src = src; <br> script.onload = () => <strong>callback</strong>(null, script); <br> script.onerror = () => callback(new Error(`Не удалось загрузить скрипт $&#123;src}`)) <br> document.head.append(script); <br>} </span></code><hr> Error first <br> <code><span class='code-example'>loadScript('/my/script.js', function(<strong>error</strong>, script) { <br> if (error) { <br> // обрабатываем ошибку <br> } else { <br> // скрипт успешно загружен <br>} <br> }) </span></code>;",
         description: ""
     },
     {
         title: "Промисы",
         shortDesc: `<code><span class='code-example'>let b = new <strong>Promise</strong>((resolve, reject) => {</span></code>  // объект, создающий код после выполнения передает результат потребляющему <br>
             <code><span class='code-example'>setTimeout(() => resolve("result"), 4000) <br> }) <br>
             .finally(() => alert("Промис завершён")) </span></code>     //всегда выполняется и пропускает результат дальше  // then, catch, finally - потребители <br> <code><span class='code-example'>.then((result)=>{ <br> alert(result + 2);  // result2 <br> return new Promise((resolve, reject) => { <br> setTimeout(() => resolve(result + 3), 4000);}); <br> }) <br> .then(result => alert(result + 4))  </span></code>   //result34 //первый аргумент функция на resolve, второй - reject(вместо catch) <br> <code><span class='code-example'>.catch(err => alert(err.message))  </span></code>  //ловит ошибку <hr>
            Если нет обработчиков ошибок, то js генерирует глобальную ошибку, ее можно словить так: <br><code><span class='code-example'>window.addEventListener('unhandledrejection', function(event) { <br> alert(event.promise); </span></code> // [object Promise] - промис, который сгенерировал ошибку <br><code><span class='code-example'>alert(event.reason); </span></code> // Error: Ошибка! - объект ошибки, которая не была обработана });<hr> </br> <code><span class='code-example'>Promise.all([ <br> new Promise(resolve => setTimeout(() => resolve(1), 3000)), <br> new Promise(resolve => setTimeout(() => resolve(2), 2000)),</span></code>     //выполняются все и если ошибка в одном идет в сatch <br> <code><span class='code-example'>new Promise(resolve => setTimeout(() => resolve(3), 1000))  <br> ]).then(alert); <hr>
            Promise.allSettled(urls.map(url => fetch(url))) <br> .then(results => { <br> results.forEach((result, num) => {  </span></code>       //выполняются все и возвращает для каждого объект {status: ..., value:...} <br> <code><span class='code-example'>if (result.status == "fulfilled") { <br> alert('$&#123;urls[num]}: $&#123;result.value.status}'); <br> } if (result.status == "rejected") { <br> alert('$&#123;urls[num]}: $&#123;result.reason}');} <br> });}); <hr>
            Promise.race([ <br> new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),<br> new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),<br> new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))</br> ]).then(alert); </span></code>   // Выполняет все, возвращает результат первого выполневшегося`,
            description: ""
     },
     {
         title: "async/await",
         shortDesc: `<code><span class='code-example'><strong>async</strong> function f() { </span></code>    // всегда возвращает промис <br> <code><span class='code-example'>let promise = new Promise((resolve, reject) => { setTimeout(() => resolve("готово!"), 1000) }); <br> let result = <strong>await</strong> promise; </span></code> // будет ждать, пока промис не выполнится (*) <br> <code><span class='code-example'>alert(result); </span></code>   // "готово!" <br>
         <code><span class='code-example'> try { <br> let response = <strong>await</strong> fetch('/no-user-here'); <br> let user = <strong>await</strong> response.json(); <br> } catch(err) { </span></code> // перехватит любую ошибку в блоке try: и в fetch, и в response.json <br> <code><span class='code-example'>alert(err); <br> }}<br> f();`,
         description: ""
     },
      {
          title: "Генераторы",
          shortDesc: "Генераторы отличаются от обычных функций тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени <hr> <code><span class='code-example'><strong>function*</strong> generateSequence() { <br>  <strong>yield</strong> 1; <br> <strong>yield</strong> 2;<br><strong>yield</strong> 3; <br> }  <br> let generator = generateSequence(); <br>let one = generator.next(); <br> alert(JSON.stringify(one)); // {value: 1, done: false}",
          description: ""
      },
      {
          title: "Async итераторы/генераторы",
          shortDesc: `[Symbol.asyncIterator] (for await..of вызывает этот метод один раз в начале) <br> <code><span class='code-example'>let range = { <br> from: 1, <br> to: 5, <br> <strong>[Symbol.asyncIterator]</strong> () { <br> return { <br> current: this.from, <br>   last: this.to, <br> <strong>async</strong> next() { </span></code> / /next() вызывается на каждой итерации цикла for await..of <br><code><span class='code-example'><strong>await</strong> new Promise(resolve => setTimeout(resolve, 1000));  <br> if (this.current <= this.last) { <br> return { done: false, value: this.current++ }; <br> } else {return { done: true };}}};} <br> } <hr> (async () => { <br>  for await (let value of range) { // (4)alert(value); // 1,2,3,4,5}  } <br> )()
            <hr><strong>async</strong> function<strong>*</strong> generateSequence(start, end) {  </span></code> //асинхронные генераторы <br> <code><span class='code-example'>for (let i = start; i <= end; i++) { <br> <strong>await</strong> new Promise(resolve => setTimeout(resolve, 1000));<br> yield i;<br>} } </span></code>`,
          description: ""
      },
      {
          title: "import/export",
          shortDesc: `<code><span class='code-example'><ol><li> export default class/function/variable ...  <ul><li>import x from "module" </li><li>  import {default as x} from "module"</li></ul> </li><li> export function sayHi(){}          <ul><li>import {sayHi} from './say.js'; </li><li> import * as say from './say.js'; </li><li> import {sayHi as hi} from './say.js';</li></ul></li><li> function sayHi(){}; export {sayHi};    <ul><li>import {sayHi} from './say.js';</li><li>import * as say from './say.js';</li></ul></li><li>export {sayHi as hi} </li><li> export {sayHi as default};    <ul><li>import {default as User, sayHi} from './user.js';</li></li></ol><hr> </span></code> Реэкспорт  <code><span class='code-example'> <ol><li>export {default as User} from './user.js';  </li><li> export {sayHi} from './say.js'; </li><li> export * from './user.js';// для реэкспорта  всех именованных экспортов </li><li>export {default} from './user.js'; // для реэкспорта экспорта по умолчанию</li></ol></span></code> <hr> Динамический импорт - import() <br><code><span class='code-example'>&lt;script> <br> async function load() { <br> let say = await <strong>import('./say.js');</strong> // может быть синхронным </br> say.hi(); // Привет! <br>say.bye(); // Пока! <br> say.default(); // Модуль загружен (экспорт по умолчанию)! <br>} <br>&lt;/script> <br><br>&lt;button onclick="load()">Нажми меня&lt;/button>`,
          description: ""
      },
      {
          title: "proxy",
          shortDesc: `Proxy - это объект обертка, который операции над собой перенаправляет на обернутый объект, а также имеет возможность их перехватывать <ul><li> Прокси не имеет своих свойст и методов, он просто перехватывает операцию или сразу перенаправляет на объект если нет хендлеров </li><li> для работы с объектами js использует внутренние низкоуровневые методы, например для чтения [[get]], записи [[set]], прокси их может перехватывать</li><li>у прокси есть инварианты (правила) которые они должны выполнять, например set  должен вернуть true or false</ul>
          <code><span class='code-example'>let numbers = [0, 1, 2]; <br><br> numbers = <strong>new Proxy</strong>(numbers, {. //обертка, которая позволяет перехватывать и перенаправлять операции на объект <br> <strong>get</strong> (target, prop) { <br> if (prop in target) {  // если у обернутого объекта есть такой проп то вернем его, если нет то вернем 0 <br>return target[prop]; <br> } else {return 0;  // значение по умолчанию}} }); <hr> let user = { name: "Вася", }; <br><br>user = <strong>new Proxy</strong>(user, { <br> <strong>get</strong>(target, prop, receiver) { <br> alert('we intercepted the call'); <br> return <strong>Reflect.get</strong>(target, prop, receiver);   // Позволяет прокси иметь доступ к внутренним свойствам  спецификации <br> }, <br> <strong>set</strong>(target, prop, val, receiver) { <br> alert('we set intercepted value'); <br> return Reflect.set(target, prop, val, receiver) <br> } }); <hr> let name = user.name; // выводит "we intercepted the call" <br> user.name = "Петя"; // выводит "we set intercepted value" <hr> 
          let object = { data: "Важные данные" }; <br> let {proxy, <strong>revoke</strong>} = Proxy.revocable(object, {});  // прокси вместо оригинального объект <br> alert(proxy.data); // Важные данны <br> // позже в коде <strong>revoke()</strong>; прокси, отключаемый вызовом специальной функции ревоук </span></code> `,
          description: ""
      },
      {
          title: "Каррирование",
          shortDesc: "Каррирование - это техника функционального программирования, когда функция, принимающая несколько аргументов, разбивается на несколько функций, принимающих один аргумент.  <br> Эта техника, позволяет передавать параметры в функцию так, чтобы они последовательно сохранились в замыкании внутренних вложенных функций. <br><br> <code><span class='code-example'>function curry(f) {   // выполняет каррирование <br> return function(a) { <br> return function(b) { <br> return f(a, b);} <br> ;}; } <hr> Использование <br> curry(new Function('a','b', 'return a + b'))(2)(4) </span></code>",
          description: ""
      }, 
      {
          title: "Двоичная система",
          shortDesc: "Двоичная система счисления с основанием 2, тоесть представление любого числа возможно только с использованием двух знаков 0 или 1  <hr> Последовательность из 32 бит <br> <table border='1px'><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>16384</td><td>8192</td><td>4096</td><td>2048</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td style='background: yellow'>16</td><td>8</td><td style='background: yellow'>4</td><td style='background: yellow'>2</td><td>1</td></tr> - число 20 (16 + 4 + 2)</table",
          description: ""
      },
      {
          title: "ООП",
          shortDesc: "ООП - основывается на трех основных принципах: <ul><li><strong>Наследование</strong> - объекты и классы наследуют данные родителей, что позволяет иметь доступ к зависимостям но утяжеляет программу</li><li><strong>Инкапсуляция</strong> - отделение внутреннего интерфейса от внешнего называется.Защищает от влияния извне внутренние переменные каждого объекта. Иногда усложняет распределение функциональности между объектами. </li><li><strong>Полиморфизм</strong> - Это практика проектирования объектов для совместного использования поведения и возможности переопределять общие поведения с конкретными. <br> Тоесть есть тип люди и тип сотрудники. Сотрудники имеют теже методы что и люди, но еще метод зарплата. Также у сотрудников метод getInfo переписан и возвращает также инфо зарплаты, тоесть полиморфно опрделен.</li></ul>",
          description: ""
      }
        

]